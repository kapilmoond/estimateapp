===== https://ezdxf.readthedocs.io/en/stable/tutorials/getting_data.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Layouts
Getting the modelspace layout
Iterate over DXF entities of a layout
Access DXF attributes of an entity
Getting a paperspace layout
Retrieve entities by query language
Extended EntityQuery Features
Retrieve entities by groupby() function
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Getting Data from DXF Files?
This tutorial shows how to get data from an existing DXF document. If you are a new user of ezdxf, read also the tutorial Usage for Beginners.

Loading the DXF file:

import sys
import ezdxf

try:
    doc = ezdxf.readfile("your_dxf_file.dxf")
except IOError:
    print(f"Not a DXF file or a generic I/O error.")
    sys.exit(1)
except ezdxf.DXFStructureError:
    print(f"Invalid or corrupted DXF file.")
    sys.exit(2)
This works well for DXF files from trusted sources like AutoCAD or BricsCAD, for loading DXF files with minor or major flaws look at the ezdxf.recover module.

See also

Document Management

Usage for Beginners

Layouts?
The term layout is used as a synonym for an arbitrary entity space which can contain DXF entities like LINE, CIRCLE, TEXT and so on. Each DXF entity can only reside in exact one layout.

There are three different layout types:

Modelspace: the common construction space

Paperspace: used to to create print layouts

BlockLayout: reusable elements, every block has its own entity space

A DXF document consist of exact one modelspace and at least one paperspace. DXF R12 has only one unnamed paperspace the later DXF versions support more than one paperspace and each paperspace has a name.

Getting the modelspace layout?
The modelspace contains the real world representation of the drawing subjects in real world units. The modelspace has the fixed name Model and the DXF document has a special getter method modelspace().

msp = doc.modelspace()
Iterate over DXF entities of a layout?
This code shows how to iterate over all DXF entities in modelspace:

# helper function
def print_entity(e):
    print("LINE on layer: %s\n" % e.dxf.layer)
    print("start point: %s\n" % e.dxf.start)
    print("end point: %s\n" % e.dxf.end)

# iterate over all entities in modelspace
msp = doc.modelspace()
for e in msp:
    if e.dxftype() == "LINE":
        print_entity(e)

# entity query for all LINE entities in modelspace
for e in msp.query("LINE"):
    print_entity(e)
All layout objects supports the standard Python iterator protocol and the in operator.

Access DXF attributes of an entity?
The e.dxftype() method returns the DXF type, the DXF type is always an uppercase string like "LINE". All DXF attributes of an entity are grouped in the namespace attribute dxf:

e.dxf.layer  # layer of the entity as string
e.dxf.color  # color of the entity as integer
See Common graphical DXF attributes

If a DXF attribute is not set (the DXF attribute does not exist), a DXFValueError will be raised. The get() method returns a default value in this case or None if no default value is specified:

# If DXF attribute 'paperspace' does not exist, the entity defaults
# to modelspace:
p = e.dxf.get("paperspace", 0)
or check beforehand if the attribute exist:

if e.dxf.hasattr("paperspace"):
    ...
An unsupported DXF attribute raises a DXFAttributeError, to check if an attribute is supported by an entity use:

if e.dxf.is_supported("paperspace"):
    ...
Getting a paperspace layout?
paperspace = doc.paperspace("layout0")
The code above retrieves the paperspace named layout0, the usage of the Paperspace object is the same as of the modelspace object. DXF R12 provides only one paperspace, therefore the paperspace name in the method call doc.paperspace("layout0") is ignored or can be left off. For newer DXF versions you can get a list of the available layout names by the methods layout_names() and layout_names_in_taborder().

Retrieve entities by query language?
Ezdxf provides a flexible query language for DXF entities. All layout types have a query() method to start an entity query or use the ezdxf.query.new() function.

The query string is the combination of two queries, first the required entity query and second the optional attribute query, enclosed in square brackets: "EntityQuery[AttributeQuery]"

The entity query is a whitespace separated list of DXF entity names or the special name *. Where * means all DXF entities, all DXF names have to be uppercase. The * search can exclude entity types by adding the entity name with a preceding ! (e.g. * !LINE, search all entities except lines).

The attribute query is used to select DXF entities by its DXF attributes. The attribute query is an addition to the entity query and matches only if the entity already match the entity query. The attribute query is a boolean expression, supported operators: and, or, !.

See also

Entity Query String

Get all LINE entities from the modelspace:

msp = doc.modelspace()
lines = msp.query("LINE")
The result container EntityQuery also provides the query() method to further refine the query, such as retrieving all LINE entities at layer construction:

construction_lines = lines.query('*[layer=="construction"]')
The * is a wildcard for all DXF types, in this case you could also use LINE instead of *, * works here because the source just contains LINE entities.

This could be executed as a single query:

lines = msp.query('LINE[layer=="construction"]')
An advanced query for getting all modelspace entities at layer construction, but excluding entities with linetype DASHED:

not_dashed_entities = msp.query('*[layer=="construction" and linetype!="DASHED"]')
Extended EntityQuery Features?
The EntityQuery class has properties and overloaded operators to build extended queries by Python features instead of a query string.

Same task as in the previous section but using features of the EntityQuery container:

# The overloaded rational operators return an EntityQuery object and not a bool value!
lines = msp.query("LINES").layer == "construction"
not_dashed_lines = lines.linetype != "DASHED"
See also

Extended EntityQuery Features

Retrieve entities by groupby() function?
The groupby() function searches and group entities by a user defined criteria. As an example let s group all entities from modelspace by layer, the result will be a dict with layer names as dict-key and a list of all entities from the modelspace matching this layer as dict-value:

from ezdxf.groupby import groupby
group = groupby(entities=msp, dxfattrib="layer")
The entities argument can be any container or generator which yields DXF entities:

group = msp.groupby(dxfattrib="layer")

for layer, entities in group.items():
    print(f'Layer "{layer}" contains following entities:')
    for entity in entities:
        print(f"    {entity}")
    print("-"*40)
The previous example shows how to group entities by a single DXF attribute. For a more advanced query create a custom key function, which accepts a DXF entity as argument and returns a hashable value as dict-key or None to exclude the entity.

The following example shows how to group entities by layer and color, the dict-key is a (layer, color) tuple and the dict-value is a list of entities with matching DXF attributes:

def layer_and_color_key(entity):
    # return None to exclude entities from the result container
    if entity.dxf.layer == "0":  # exclude entities from default layer "0"
        return None
    else:
        return entity.dxf.layer, entity.dxf.color

group = msp.groupby(key=layer_and_color_key)
for key, entities in group.items():
    print(f'Grouping criteria "{key}" matches following entities:')
    for entity in entities:
        print(f"    {entity}")
    print("-"*40)
The groupby() function catches DXFAttributeError exceptions while processing entities and excludes this entities from the result. There is no need to worry about DXF entities which do not support certain attributes, they will be excluded automatically.

See also

groupby() documentation

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/simple_drawings.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Predefined Resources
Simple DXF R12 drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Creating DXF Drawings
Tutorial for Creating DXF Drawings?
Create a new DXF document by the ezdxf.new() function:

import ezdxf

# create a new DXF R2010 document
doc = ezdxf.new("R2010")

# add new entities to the modelspace
msp = doc.modelspace()
# add a LINE entity
msp.add_line((0, 0), (10, 0))
# save the DXF document
doc.saveas("line.dxf")
New entities are always added to layouts, a layout can be the modelspace, a paperspace layout or a block layout.

See also

Thematic Index of Layout Factory Methods

Predefined Resources?
Ezdxf creates new DXF documents with as little content as possible, this means only the resources that are absolutely necessary are created. The ezdxf.new() function can create some standard resources, such as linetypes and text styles, by setting the argument setup to True.

import ezdxf

doc = ezdxf.new("R2010", setup=True)
msp = doc.modelspace()
msp.add_line((0, 0), (10, 0), dxfattribs={"linetype": "DASHED"})
The defined standard linetypes are shown in the basic concept section for Linetypes and the available text styles are shown in the Tutorial for Text.

Important

To see the defined text styles in a DXF viewer or CAD application, the applications have to know where the referenced TTF fonts can be found. This configuration is not possible by ezdxf and has to be done for each application as described in their documentation.

See also: Font Resources

Simple DXF R12 drawings?
The r12writer add-on creates simple DXF R12 drawings with a restricted set of DXF types: LINE, CIRCLE, ARC, TEXT, POINT, SOLID, 3DFACE and POLYLINE.

The advantage of the r12writer is the speed and the small memory footprint, all entities are written directly to a file or stream without creating a document structure in memory.

See also

r12writer

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/common_graphical_attributes.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Color
True Color
Transparency
Linetype
Lineweight
Linetype Scale
Invisible
GfxAttribs
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Common Graphical Attributes
Tutorial for Common Graphical Attributes?
The graphical attributes color, linetype, lineweight, true_color, transparency, ltscale and invisible are available for all graphical DXF entities and are located in the DXF namespace attribute dxf of the DXF entities. All these attributes are optional and all except for true_color and transparency have a default value.

Not all of these attributes are supported by all DXF versions. This table shows the minimum required DXF version for each attribute:

R12

color, linetype

R2000

lineweight, ltscale, invisible

R2004

true_color, transparency

Color?
Please read the section about the AutoCAD Color Index (ACI) to understand the basics.

The usage of the color attribute is very straight forward. Setting the value is:

entity.dxf.color = 1
and getting the value looks like this:

value = entity.dxf.color
The color attribute has a default value of 256, which means take the color defined by the layer associated to the entity. The ezdxf.colors module defines some constants for often used color values:

entity.dxf.color = ezdxf.colors.RED
The ezdxf.colors.aci2rgb() function converts the ACI value to the RGB value of the default modelspace palette.

See also

Basics about AutoCAD Color Index (ACI)

ezdxf.colors module

True Color?
Please read the section about True Color to understand the basics.

The easiest way is to use the rgb property to set and get the true color values as RGB tuples:

entity.rgb = (255, 128, 16)
The rgb property return None if the true_color attribute is not present:

rgb = entity.rgb
if rgb is not None:
    r, g, b = rgb
Setting and getting the true_color DXF attribute directly is possible and the ezdxf.colors module has helper function to convert RGB tuples to 24-bit value and back:

entity.dxf.true_color = ezdxf.colors.rgb2int(255, 128, 16)
The true_color attribute is optional does not have a default value and therefore it is not safe to use the attribute directly, check if the attribute exists beforehand:

if entity.dxf.hasattr("true_color"):
    r, g, b = ezdxf.colors.int2rgb(entity.dxf.true_color)
or use the get() method of the dxf namespace attribute to get a default value if the attribute does not exist:

r, g, b = ezdxf.colors.int2rgb(entity.dxf.get("true_color", 0)
See also

Basics about True Color

ezdxf.colors module

Transparency?
Please read the section about Transparency to understand the basics.

It s recommended to use the transparency property of the DXFGraphic base class. The transparency property is a float value in the range from 0.0 to 1.0 where 0.0 is opaque and 1.0 if fully transparent:

entity.transparency = 0.5
or set the values of the DXF attribute by constants defined in the ezdxf.colors module:

entity.dxf.transparency = ezdxf.colors.TRANSPARENCY_50
The default setting for transparency in CAD applications is always transparency by layer, but the transparency property in ezdxf has a default value of 0.0 (opaque), so there are additional entity properties to check if the transparency value should be taken from the associated entity layer or from the parent block:

if entity.is_transparency_by_layer:
    ...
elif entity.is_transparency_by_block:
    ...
else:
    ...
The top level entity attribute transparency does not support setting transparency by layer or block:

from ezdxf import colors

...

# set transparency by layer by removing the DXF attribute "transparency":
entity.dxf.discard("transparency")

# set transparency by block:
entity.dxf.transparency = colors.TRANSPARENCY_BYBLOCK

# there are also some handy constants in the colors module:
# TRANSPARENCY_10 upto TRANSPARENCY_90 in steps of 10
entity.dxf.transparency = colors.TRANSPARENCY_30  # set 30% transparency
entity.dxf.transparency = colors.OPAQUE
See also

Basics about Transparency

ezdxf.colors module

Linetype?
Please read the section about Linetypes to understand the basics.

The linetype attribute contains the name of the linetype as string and can be set by the dxf namespace attribute directly:

entity.dxf.linetype = "DASHED"  # linetype DASHED must exist!
The linetype attribute is optional and has a default value of BYLAYER , so the attribute can always be used without any concerns:

name = entity.dxf.linetype
Warning

Make sure the linetype you assign to an entity is really defined in the linetype table otherwise AutoCAD will not open the DXF file. There are no implicit checks for that by ezdxf but you can call the audit() method of the DXF document explicitly to validate the document before exporting.

Ezdxf creates new DXF documents with as little content as possible, this means only the resources that are absolutely necessary are created. The ezdxf.new() function can create some standard linetypes by setting the argument setup to True:

doc = ezdxf.new("R2010", setup=True)
See also

Basics about Linetypes

Tutorial for Creating Linetype Pattern

Lineweight?
Please read the section about Lineweights to understand the basics.

The lineweight attribute contains the lineweight as an integer value and can be set by the dxf namespace attribute directly:

entity.dxf.lineweight = 25
The lineweight value is the line width in millimeters times 100 e.g. 0.25mm = 25, but only certain values are valid for more information go to section: Lineweights.

Values < 0 have a special meaning and can be imported as constants from ezdxf.lldxf.const

-1

LINEWEIGHT_BYLAYER

-2

LINEWEIGHT_BYBLOCK

-3

LINEWEIGHT_DEFAULT

The lineweight attribute is optional and has a default value of -1, so the attribute can always be used without any concerns:

lineweight = entity.dxf.lineweight
Important

You have to enable the option to show lineweights in your CAD application or viewer to see the effect on screen, which is disabled by default, the same has to be done in the page setup options for plotting lineweights.

# activate on screen lineweight display
doc.header["$LWDISPLAY"] = 1
See also

Basics about Lineweights

Linetype Scale?
The ltscale attribute scales the linetype pattern by a float value and can be set by the dxf namespace attribute directly:

entity.dxf.ltscale = 2.0
The ltscale attribute is optional and has a default value of 1.0, so the attribute can always be used without any concerns:

scale = entity.dxf.ltscale
See also

Basics about Linetypes

Invisible?
The invisible attribute an boolean value (0/1) which defines if an entity is invisible or visible and can be set by the dxf namespace attribute directly:

entity.dxf.invisible = 1
The invisible attribute is optional and has a default value of 0, so the attribute can always be used without any concerns:

is_invisible = bool(entity.dxf.invisible)
GfxAttribs?
When adding new entities to an entity space like the modelspace or a block definition, the factory methods expect the graphical DXF attributes by the argument dxfattribs. This object can be a Python dict where the key is the DXF attribute name and the value is the attribute value, or better use the GfxAttribs object which has some additional validation checks and support for code completions by IDEs:

import ezdxf
from ezdxf.gfxattribs import GfxAttribs

doc = ezdxf.new()
msp = doc.modelspace()

line = msp.add_line(
    (0, 0), (10, 10), dxfattribs=GfxAttribs(layer="0", rgb=(25, 128, 16))
)
See also

ezdxf.gfxattribs module

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/layers.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Create a Layer Definition
Moving an Entity to a Different Layer
Changing Layer State
Check Available Layers
Renaming a Layer
Deleting a Layer Definition
Deleting All Entities From a Layer
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Layers
Tutorial for Layers?
If you are not familiar with the concept of layers, please read this first: Concept of Layers

Reminder: a layer definition is not required for using a layer!

Create a Layer Definition?
import ezdxf

doc = ezdxf.new(setup=True)  # setup required line types
msp = doc.modelspace()
doc.layers.add(name="MyLines", color=7, linetype="DASHED")
The advantage of assigning a linetype and a color to a layer is that entities on this layer can inherit this properties by using "BYLAYER" as linetype string and 256 as color, both values are default values for new entities so you can leave off these assignments:

msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})
The new created line will be drawn with color 7 and linetype "DASHED".

Moving an Entity to a Different Layer?
Moving an entity to a different layer is a simple assignment of the new layer name to the layer attribute of the entity.

line = msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})
# move the entity to layer "OtherLayer"
line.dxf.layer = "OtherLayer"
Changing Layer State?
Get the layer definition object from the layer table:

my_lines = doc.layers.get('MyLines')
Check the state of the layer:

my_lines.is_off()  # True if layer is off
my_lines.is_on()   # True if layer is on
my_lines.is_locked()  # True if layer is locked
layer_name = my_lines.dxf.name  # get the layer name
Change the state of the layer:

# switch layer off, entities at this layer will not shown in CAD applications/viewers
my_lines.off()

# lock layer, entities at this layer are not editable in CAD applications
my_lines.lock()
Get/set the color of a layer by property Layer.color, because the DXF attribute Layer.dxf.color is misused for switching the layer on and off, the layer is off if the color value is negative.

Changing the layer properties:

my_lines.dxf.linetype = "DOTTED"
my_lines.color = 13  # preserves on/off state of layer
See also

For all methods and attributes see class Layer.

Check Available Layers?
The LayerTable object supports some standard Python protocols:

# iteration
for layer in doc.layers:
    if layer.dxf.name != "0":
        layer.off()  # switch all layers off except layer "0"

# check for existing layer definition
if "MyLines" in doc.layers:
    layer = doc.layers.get("MyLines")

layer_count = len(doc.layers) # total count of layer definitions
Renaming a Layer?
The Layer class has a method for renaming the layer, but has same limitations, not all places where layer references can occur are documented, third-party entities are black-boxes with unknown content and layer references could be stored in the extended data section of any DXF entity or in a XRECORD entity, so some references may reference a non-existing layer definition after the renaming, at least these references are still valid, because a layer definition is not required for using a layer.

my_lines = doc.layers.get("MyLines")
my_lines.rename("YourLines")
Deleting a Layer Definition?
Delete a layer definition:

doc.layers.remove("MyLines")
This just deletes the layer definition, all DXF entities referencing this layer still exist, if they inherit any properties from the deleted layer they will now get the default layer properties.

Warning

The behavior of entities referencing the layer by handle is unknown and may break the DXF document.

Deleting All Entities From a Layer?
Because of all these uncertainties about layer references mentioned above, deleting all entities referencing a certain layer from a DXF document is not implemented as an API call!

Nonetheless deleting all graphical entities from the DXF document which do reference a certain layer by the layer attribute is a safe procedure:

key_func = doc.layers.key
layer_key = key_func("MyLines")
# The trashcan context-manager is a safe way to delete entities from the
# entities database while iterating.
with doc.entitydb.trashcan() as trash:
    for entity in doc.entitydb.values():
        if not entity.dxf.hasattr("layer"):
            continue
        if layer_key == key_func(entity.dxf.layer):
            # safe destruction while iterating
            trash.add(entity.dxf.handle)
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/linetypes.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Check Available Linetypes
Removing Linetypes
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Creating Linetype Pattern
Tutorial for Creating Linetype Pattern?
Simple line type example:

../_images/ltype_simple.jpg
You can define your own linetypes. A linetype definition has a name, a description and line pattern elements:

elements = [total_pattern_length, elem1, elem2, ...]
total_pattern_length
Sum of all linetype elements (absolute values)

elem
if elem > 0 it is a line, if elem < 0 it is gap, if elem == 0.0 it is a dot

Create a new linetype definition:

import ezdxf
from ezdxf.tools.standards import linetypes  # some predefined linetypes

doc = ezdxf.new()
msp = doc.modelspace()

my_line_types = [
    (
        "DOTTED",
        "Dotted .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .",
        [0.2, 0.0, -0.2],
    ),
    (
        "DOTTEDX2",
        "Dotted (2x) .    .    .    .    .    .    .    . ",
        [0.4, 0.0, -0.4],
    ),
    (
        "DOTTED2",
        "Dotted (.5) . . . . . . . . . . . . . . . . . . . ",
        [0.1, 0.0, -0.1],
    ),
]
for name, desc, pattern in my_line_types:
    if name not in doc.linetypes:
        doc.linetypes.add(
            name=name,
            pattern=pattern,
            description=desc,
        )
Setup some predefined linetypes:

for name, desc, pattern in linetypes():
    if name not in doc.linetypes:
        doc.linetypes.add(
            name=name,
            pattern= pattern,
            description=desc,
        )
Check Available Linetypes?
The linetypes object supports some standard Python protocols:

# iteration
print("available linetypes:")
for lt in doc.linetypes:
    print(f"{lt.dxf.name}: {lt.dxf.description}")

# check for existing linetype
if "DOTTED" in doc.linetypes:
    pass

count = len(doc.linetypes) # total count of linetypes
Removing Linetypes?
Warning

Ezdxf does not check if a linetype is still in use and deleting a linetype which is still in use generates an invalid DXF file. The audit process audit() of the DXF document removes linetype attributes referencing non existing linetypes.

You can delete a linetype:

doc.layers.remove("DASHED")
This just removes the linetype definition, the linetype attribute of DXF entities may still refer the removed linetype definition DASHED and AutoCAD will not open DXF files including undefined linetypes.

Tutorial for Creating Complex Linetype Pattern?
In DXF R13 Autodesk introduced complex linetypes, containing TEXT or SHAPES in line types.

Complex linetype example with text:

../_images/ltype_text.jpg
Complex line type example with shapes:

../_images/ltype_shape.jpg
For easy usage the pattern string for complex line types is mostly the same string as the pattern definition strings in AutoCAD .lin files.

Example for complex line type TEXT:

doc = ezdxf.new("R2018")  # DXF R13 or later is required

doc.linetypes.add(
    name="GASLEITUNG2",
    # linetype definition string from acad.lin:
    pattern='A,.5,-.2,["GAS",STANDARD,S=.1,U=0.0,X=-0.1,Y=-.05],-.25',
    description= "Gasleitung2 ----GAS----GAS----GAS----GAS----GAS----",
    length=1,  # required for complex line types
})
The pattern always starts with an A , the following float values have the same meaning as for simple linetypes, a value > 0 is a line, a value < 0 is a gap, and a 0 is a point, the opening square bracket [ starts the complex part of the linetype pattern.

The text after the [ defines the complex linetype:

A text in quotes (e.g. GAS ) defines a complex TEXT linetype and represents the pattern text itself.

A text without quotes is a SHAPE name (in .lin files) and defines a complex SHAPE linetype. Ezdxf can not translate this SHAPE name from the .lin file into the required shape file index, so *YOU have to translate this SHAPE name into the shape file index, e.g. saving the file with AutoCAD as DXF and searching for the DXF linetype definition, see example below and the DXF Internals: LTYPE Table.

For complex TEXT linetypes the second parameter is the text style, for complex SHAPE linetypes the second parameter is the shape file name, the shape file has to be in the same directory as the DXF file or in one of the CAD application support paths.

The meaning of the following comple linetype parameters are shown in the table below:

S

scaling factor, always > 0, if S=0 the TEXT or SHAPE is not visible

R or U

rotation relative to the line direction

X

x-direction offset (along the line)

Y

y-direction offset (perpendicular to the line)

These parameters are case insensitive and the closing square bracket ] ends the complex part of the linetype pattern.

The fine tuning of this parameters is a try an error process, for complex TEXT linetypes the scaling factor (e.g. the STANDARD text style) sets the text height (e.g. S=0.1 sets the text height to 0.1 units), by shifting in y-direction by half of the scaling factor, the text is vertically centered to the line. For the x-direction it seems to be a good practice to place a gap in front of the text and after the text, find x shifting value and gap sizes by try and error. The overall length is at least the sum of all line and gap definitions (absolute values).

Example for complex line type SHAPE:

doc.linetypes.add("GRENZE2",
    # linetype definition in acad.lin:
    # A,.25,-.1,[BOX,ltypeshp.shx,x=-.1,s=.1],-.1,1
    # replacing BOX by shape index 132 (got index from an AutoCAD file),
    # ezdxf can't get shape index from ltypeshp.shx
    pattern="A,.25,-.1,[132,ltypeshp.shx,x=-.1,s=.1],-.1,1",
    description="Grenze eckig ----[]-----[]----[]-----[]----[]--",
    length= 1.45,  # required for complex line types
})
Complex line types with shapes only work if the associated shape file (e. g. ltypeshp.shx) and the DXF file are in the same directory or the shape file is placed in one of the CAD application support folders.

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/complex_linetypes.html ===== [Fetch failed] ===== https://ezdxf.readthedocs.io/en/stable/tutorials/dxf_primitives.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Point
Line
Circle
Arc
Ellipse
Further Tutorials
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Simple DXF Entities
Tutorial for Simple DXF Entities?
These are basic graphical entities located in an entity space like the modelspace or a block definition and only support the common graphical attributes.

The entities in the following examples are always placed in the xy-plane of the WCS aka the 2D drawing space. Some of these entities can only be placed outside the xy-plane in 3D space by utilizing the OCS, but this feature is beyond the scope of this tutorial, for more information about that go to: Tutorial for OCS/UCS Usage.

Prelude to all following examples:

import ezdxf
from ezdxf.gfxattribs import GfxAttribs

doc = ezdxf.new()
doc.layers.new("ENTITY", color=1)
msp = doc.modelspace()
attribs = GfxAttribs(layer="ENTITY")
See also

Tutorial for Creating DXF Drawings

Tutorial for Layers

ezdxf.gfxattribs module

Point?
The Point entity marks a 3D point in the WCS:

point = msp.add_point((10, 10), dxfattribs=attribs)
All Point entities have the same styling stored in the header variable $PDMODE, for more information read the reference of class Point.

See also

Reference of class Point

Tutorial for Common Graphical Attributes

Line?
The Line entity is a 3D line with a start- and an end point in the WCS:

line = msp.add_line((0, 0), (10, 10), dxfattribs=attribs)
See also

Reference of class Line

Tutorial for Common Graphical Attributes

ezdxf.math.ConstructionLine

Circle?
The Circle entity is an OCS entity defined by a center point and a radius:

circle = msp.add_circle((10, 10), radius=3, dxfattribs=attribs)
See also

Reference of class Circle

Tutorial for Common Graphical Attributes

ezdxf.math.ConstructionCircle

Arc?
The Arc entity is an OCS entity defined by a center point, a radius a start- and an end angle in degrees:

arc = msp.add_arc((10, 10), radius=3, start_angle=30, end_angle=120, dxfattribs=attribs)
The arc goes always in counter-clockwise orientation around the z-axis more precisely the extrusion vector of OCS, but this is beyond the scope of this tutorial.

The helper class ezdxf.math.ConstructionArc provides constructors to create arcs from different scenarios:

from_2p_angle: arc from 2 points and an angle

from_2p_radius: arc from 2 points and a radius

from_3p: arc from 3 points

This example creates an arc from point (10, 0) to point (0, 0) passing the point (5, 3):

from ezdxf.math import ConstructionArc

# -x-x-x- snip -x-x-x-

arc = ConstructionArc.from_3p(
    start_point=(10, 0), end_point=(0, 0), def_point=(5, 3)
)
arc.add_to_layout(msp, dxfattribs=attribs)
See also

Reference of class Arc

Tutorial for Common Graphical Attributes

ezdxf.math.ConstructionArc

Ellipse?
The Ellipse entity requires DXF R2000 or newer and is a true WCS entity. The ellipse is defined by a center point, a vector for the major axis, the ratio between major- and minor axis and the start- and end parameter in radians:

ellipse = msp.add_ellipse(
    (10, 10), major_axis=(5, 0), ratio=0.5, start_param=0, end_param=math.pi, dxfattribs=attribs
)
When placed in 3D space the extrusion vector defines the normal vector of the ellipse plane and the minor axis is the extrusion vector cross the major axis.

See also

Reference of class Ellipse

Tutorial for Common Graphical Attributes

ezdxf.math.ConstructionEllipse

Further Tutorials?
Tutorial for LWPolyline

Tutorial for Spline

Tutorial for Text

Tutorial for MText and MTextEditor

Tutorial for Hatch

Tutorial for MultiLeader

Tutorial for Mesh

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/entity_query.html ===== [Fetch failed]
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Create a Block
Block References (Insert)
Block Attributes
Using Attribute Definitions
Get/Set Attributes of Existing Block References
Evaluate Wrapped Block References
Exploding Block References
Examine Entities of Block References
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Blocks
Tutorial for Blocks?
If you are not familiar with the concept of blocks, please read this first: Concept of Blocks

Create a Block?
Blocks are managed as BlockLayout objects by the BlocksSection object, every drawing has only one blocks section referenced by attribute Drawing.blocks.

import ezdxf
import random  # needed for random placing points


def get_random_point():
    """Returns random x, y coordinates."""
    x = random.randint(-100, 100)
    y = random.randint(-100, 100)
    return x, y


# Create a new drawing in the DXF format of AutoCAD 2010
doc = ezdxf.new('R2010')

# Create a block with the name 'FLAG'
flag = doc.blocks.new(name='FLAG')

# Add DXF entities to the block 'FLAG'.
# The default base point (= insertion point) of the block is (0, 0).
flag.add_lwpolyline([(0, 0), (0, 5), (4, 3), (0, 3)])  # the flag symbol as 2D polyline
flag.add_circle((0, 0), .4, dxfattribs={'color': 2})  # mark the base point with a circle
Block References (Insert)?
A block reference can be created by adding an Insert entity to any of these layout types:

Modelspace

Paperspace

BlockLayout

A block reference can be scaled and rotated individually. Lets add some random flags to the modelspace:

# Get the modelspace of the drawing.
msp = doc.modelspace()

# Get 50 random placing points.
placing_points = [get_random_point() for _ in range(50)]

for point in placing_points:
    # Every flag has a different scaling and a rotation of -15 deg.
    random_scale = 0.5 + random.random() * 2.0
    # Add a block reference to the block named 'FLAG' at the coordinates 'point'.
    msp.add_blockref('FLAG', point, dxfattribs={
        'xscale': random_scale,
        'yscale': random_scale,
        'rotation': -15
    })

# Save the drawing.
doc.saveas("blockref_tutorial.dxf")
Query all block references of block FLAG:

for flag_ref in msp.query('INSERT[name=="FLAG"]'):
    print(str(flag_ref))
When adding a block reference to a layout with different units, the scaling factor between these units should be applied as scaling attributes (xscale, ) e.g. modelspace in meters and block in centimeters, xscale has to be 0.01.

Block Attributes?
A block attribute (Attrib) is a text annotation attached to a block reference with an associated tag. Attributes are often used to add information to blocks which can be evaluated and exported by CAD applications. An attribute can be added to a block reference by the Insert.add_attrib() method, the ATTRIB entity is geometrically not related to the block reference, so insertion point, rotation and scaling of the attribute have to be calculated by the user, but helper tools for that do exist.

Using Attribute Definitions?
Another way to add attributes to block references is using attribute templates (AttDef). First create the attribute definition in the block definition, then add the block reference by add_blockref() and attach and fill attributes automatically by the add_auto_attribs() method to the block reference. This method has the advantage that all attributes are placed relative to the block base point with the same rotation and scaling as the block reference, but non-uniform scaling is not handled very well.

The add_auto_blockref() method handles non-uniform scaling better by wrapping the block reference and its attributes into an anonymous block and let the CAD application do the transformation work. This method has the disadvantage of a more complex evaluation of attached attributes

Using attribute definitions (AttDef templates):

# Define some attributes for the block 'FLAG', placed relative
# to the base point, (0, 0) in this case.
flag.add_attdef('NAME', (0.5, -0.5), dxfattribs={'height': 0.5, 'color': 3})
flag.add_attdef('XPOS', (0.5, -1.0), dxfattribs={'height': 0.25, 'color': 4})
flag.add_attdef('YPOS', (0.5, -1.5), dxfattribs={'height': 0.25, 'color': 4})

# Get another 50 random placing points.
placing_points = [get_random_point() for _ in range(50)]

for number, point in enumerate(placing_points):
    # values is a dict with the attribute tag as item-key and
    # the attribute text content as item-value.
    values = {
        'NAME': "P(%d)" % (number + 1),
        'XPOS': "x = %.3f" % point[0],
        'YPOS': "y = %.3f" % point[1]
    }

    # Every flag has a different scaling and a rotation of +15 deg.
    random_scale = 0.5 + random.random() * 2.0
    blockref = msp.add_blockref('FLAG', point, dxfattribs={
        'rotation': 15
    }).set_scale(random_scale)
    blockref.add_auto_attribs(values)

# Save the drawing.
doc.saveas("auto_blockref_tutorial.dxf")
Get/Set Attributes of Existing Block References?
See the howto: Get/Set Block Reference Attributes

Evaluate Wrapped Block References?
As mentioned above the evaluation of block references wrapped into anonymous blocks is complex:

# Collect all anonymous block references starting with '*U'
anonymous_block_refs = modelspace.query('INSERT[name ? "^\*U.+"]')

# Collect the references of the 'FLAG' block
flag_refs = []
for block_ref in anonymous_block_refs:
    # Get the block layout of the anonymous block
    block = doc.blocks.get(block_ref.dxf.name)
    # Find all block references to 'FLAG' in the anonymous block
    flag_refs.extend(block.query('INSERT[name=="FLAG"]'))

# Evaluation example: collect all flag names.
flag_numbers = [
    flag.get_attrib_text("NAME")
    for flag in flag_refs
    if flag.has_attrib("NAME")
]

print(flag_numbers)
Exploding Block References?
This is an advanced feature and the results may not be perfect. A non-uniform scaling lead to incorrect results for text entities (TEXT, MTEXT, ATTRIB) and some other entities like HATCH with circular- or elliptic path segments. The exploded entities are added to the same layout as the block reference by default.

for flag_ref in msp.query('INSERT[name=="FLAG"]'):
    flag_ref.explode()
Examine Entities of Block References?
To just examine the content entities of a block reference use the virtual_entities() method. This methods yields virtual entities with properties identical to exploded entities but they are not stored in the entity database, have no handle and are not assigned to any layout.

for flag_ref in msp.query('INSERT[name=="FLAG"]'):
    for entity in flag_ref.virtual_entities():
        if entity.dxftype() == "LWPOLYLINE":
            print(f"Found {str(entity)}.")
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/text.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Standard Text Styles
New Text Style
3D Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Text
Tutorial for Text?
Add a simple one line text entity by factory function add_text().

import ezdxf
from ezdxf.enums import TextEntityAlignment

# The TEXT entity is a DXF primitive and is supported in all DXF versions.
# The argument setup=True creates standard linetypes and text styles in the
# new DXF document.
doc = ezdxf.new("R12", setup=True)
msp = doc.modelspace()

# Use method set_placement() to define the TEXT alignment, because the
# relations between the DXF attributes 'halign', 'valign', 'insert' and
# 'align_point' are tricky.
msp.add_text("A Simple Text").set_placement(
    (2, 3),
    align=TextEntityAlignment.MIDDLE_RIGHT
)

# Using a predefined text style:
msp.add_text(
    "Text Style Example: Liberation Serif",
    height=0.35,
    dxfattribs={"style": "LiberationSerif"}
).set_placement((2, 6), align=TextEntityAlignment.LEFT)

doc.saveas("simple_text.dxf")
Alignments defined by the enum TextEntityAlignment:

Vert/Horiz

Left

Center

Right

Top

TOP_LEFT

TOP_CENTER

TOP_RIGHT

Middle

MIDDLE_LEFT

MIDDLE_CENTER

MIDDLE_RIGHT

Bottom

BOTTOM_LEFT

BOTTOM_CENTER

BOTTOM_RIGHT

Baseline

LEFT

CENTER

RIGHT

Special alignments are ALIGNED and FIT, they require a second alignment point, the text is justified with the vertical alignment Baseline on the virtual line between these two points.

Alignment

Description

ALIGNED

Text is stretched or compressed to fit exactly between p1 and p2 and the text height is also adjusted to preserve height/width ratio.

FIT

Text is stretched or compressed to fit exactly between p1 and p2 but only the text width is adjusted, the text height is fixed by the height attribute.

MIDDLE

also a special adjustment, but the result is the same as for MIDDLE_CENTER.

Standard Text Styles?
Setup some standard text styles and linetypes by argument setup=True:

doc = ezdxf.new('R12', setup=True)
Replaced all proprietary font declarations in setup_styles() (ARIAL, ARIAL_NARROW, ISOCPEUR and TIMES) by open source fonts, this is also the style name (e.g. {'style': 'OpenSans-Italic'}):

../_images/fonts.png
Important

To see the defined text styles in a DXF viewer or CAD application, the applications have to know where the referenced TTF fonts can be found. This configuration is not possible by ezdxf and has to be done for each application as described in their documentation.

See also: Font Resources

New Text Style?
Creating a new text style is simple:

doc.styles.new("myStandard", dxfattribs={"font" : "OpenSans-Regular.ttf"})
Getting the correct font name is often not that simple, especially on Windows. This shows the required steps to get the font name for Open Sans:

open font folder c:\windows\fonts

select and open the font-family Open Sans

right-click on Open Sans Standard and select Properties

on top of the first tab you see the font name: 'OpenSans-Regular.ttf'

The style name has to be unique in the DXF document, otherwise ezdxf will raise an DXFTableEntryError exception. To replace an existing entry, delete the existing entry by doc.styles.remove(name), and add the replacement entry.

3D Text?
It is possible to place the 2D Text entity into 3D space by using the OCS, for further information see: Tutorial for OCS/UCS Usage and Tutorial for UCS Based Transformations.

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/spline.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Splines from fit points
Splines by control points
Open Spline
Rational Spline
Spline Tangents
Spline properties
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Spline
Tutorial for Spline?
Background information about B-spline at Wikipedia.

Splines from fit points?
Splines can be defined by fit points only, this means the curve passes all given fit points. AutoCAD and BricsCAD generates required control points and knot values by itself, if only fit points are present.

Create a simple spline:

doc = ezdxf.new("R2000")

fit_points = [(0, 0, 0), (750, 500, 0), (1750, 500, 0), (2250, 1250, 0)]
msp = doc.modelspace()
spline = msp.add_spline(fit_points)
../_images/spline1.png
Append a fit point to a spline:

# fit_points, control_points, knots and weights are list-like containers:
spline.fit_points.append((2250, 2500, 0))
../_images/spline2.png
You can set additional control points, but if they do not fit the auto-generated AutoCAD values, they will be ignored and don t mess around with knot values.

doc = ezdxf.readfile("AutoCAD_generated.dxf")

msp = doc.modelspace()
spline = msp.query("SPLINE").first

# fit_points, control_points, knots and weights are list-like objects:
spline.fit_points.append((2250, 2500, 0))
As far as I have tested, this approach works without complaints from AutoCAD, but for the case of problems remove invalid data from the SPLINE entity:

# current control points do not match spline defined by fit points
spline.control_points = []

# count of knots is not correct:
# count of knots = count of control points + degree + 1
spline.knots = []

# same for weights, count of weights == count of control points
spline.weights = []
Splines by control points?
Creating splines from fit points is the easiest way, but this method is also the least accurate, because a spline is defined by control points and knot values, which are generated for the case of a definition by fit points, and the worst fact is that for every given set of fit points exist an infinite number of possible splines as solution.

To ensure the same spline geometry for all CAD applications, the spline has to be defined by control points. The method add_spline_control_frame() adds a spline passing the given fit points by calculating the control points by the Global Curve Interpolation algorithm. There is also a low level function ezdxf.math.global_bspline_interpolation() which calculates the control points from fit points.

msp.add_spline_control_frame(fit_points, method='uniform', dxfattribs={'color': 1})
msp.add_spline_control_frame(fit_points, method='chord', dxfattribs={'color': 3})
msp.add_spline_control_frame(fit_points, method='centripetal', dxfattribs={'color': 5})
black curve: AutoCAD/BricsCAD spline generated from fit points

red curve: spline curve interpolation, uniform method

green curve: spline curve interpolation, chord method

blue curve: spline curve interpolation, centripetal method

../_images/spline3.png
Since ezdxf v1.1 the method add_cad_spline_control_frame() calculates the same control points from fit points as AutoCAD and BricsCAD.

Open Spline?
Add and open (clamped) spline defined by control points with the method add_open_spline(). If no knot values are given, an open uniform knot vector will be generated. A clamped B-spline starts at the first control point and ends at the last control point.

control_points = [(0, 0, 0), (1250, 1560, 0), (3130, 610, 0), (2250, 1250, 0)]
msp.add_open_spline(control_points)
../_images/spline4.png
Rational Spline?
Rational B-splines have a weight for every control point, which can raise or lower the influence of the control point, default weight = 1, to lower the influence set a weight < 1 to raise the influence set a weight > 1. The count of weights has to be always equal to the count of control points.

Example to raise the influence of the first control point:

msp.add_rational_spline(control_points, weights=[3, 1, 1, 1])
../_images/spline6.png
Spline Tangents?
The tangents of a spline are the directions of the first derivative of the curve:

# additional required imports:
from ezdxf.math import Vec3, estimate_tangents
import numpy as np

# snip -x-x-x-

fit_points = Vec3.list(
    [
        (0, 0, 0),
        (1000, 600, 0),
        (1500, 1200, 0),
        (500, 1250, 0),
        (0, 0, 0),
    ]
)
spline = msp.add_spline(fit_points)

# draw the curve tangents as red lines:
ct = spline.construction_tool()
for t in np.linspace(0, ct.max_t, 30):
    point, derivative = ct.derivative(t, 1)
    msp.add_line(point, point + derivative.normalize(200), dxfattribs={"color": 1})
../_images/spline7.png
To get a smooth closed curve the start- and end tangents have to be set manually when the control points are calculated and they have to point in the same direction:

t0= Vec3(1, -1, 0)  # the length (magnitude) of the tangent is not relevant!
spline = msp.add_cad_spline_control_frame(fit_points, tangents=[t0, t0])
../_images/spline8.png
To avoid guess work the function ezdxf.math.estimate_tangents() can be used to estimate the start- and end tangents of the curve:

tangents = estimate_tangents(fit_points)
# linear interpolation of the first and the last tangent:
t0 = tangents[0].lerp(tangents[-1], 0.5)
msp.add_cad_spline_control_frame(fit_points, tangents=[t0, t0])
../_images/spline9.png
It is also possible to add the SPLINE by fit-points and setting the tangents as DXF attributes:

spline = msp.add_spline(fit_points)
spline.dxf.flags = spline.PERIODIC | spline.CLOSED
spline.dxf.start_tangent = t0
spline.dxf.end_tangent = t0
Spline properties?
Check if spline is a closed curve or close/open spline, for a closed spline the last point is connected to the first point:

if spline.closed:
    # this spline is closed
    pass

# close spline
spline.closed = True

# open spline
spline.closed = False
Set start- and end tangent for splines defined by fit points:

spline.dxf.start_tangent = (0, 1, 0)
spline.dxf.end_tangent = (0, 1, 0)
Get data count as stored in DXF attributes:

count = spline.dxf.n_fit_points
count = spline.dxf.n_control_points
count = spline.dxf.n_knots
Get data count from existing data:

count = spline.fit_point_count
count = spline.control_point_count
count = spline.knot_count
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/mesh.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Mesh
Tutorial for Mesh?
The Mesh entity is a 3D object in WCS build up from vertices and faces.

Create a cube mesh by directly accessing the base data structures:

import ezdxf


# 8 corner vertices
cube_vertices = [
    (0, 0, 0),
    (1, 0, 0),
    (1, 1, 0),
    (0, 1, 0),
    (0, 0, 1),
    (1, 0, 1),
    (1, 1, 1),
    (0, 1, 1),
]

# 6 cube faces
cube_faces = [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [0, 1, 5, 4],
    [1, 2, 6, 5],
    [3, 2, 6, 7],
    [0, 3, 7, 4]
]

# MESH requires DXF R2000 or later
doc = ezdxf.new("R2000")
msp = doc.modelspace()
mesh = msp.add_mesh()
# do not subdivide cube, 0 is the default value
mesh.dxf.subdivision_levels = 0
with mesh.edit_data() as mesh_data:
    mesh_data.vertices = cube_vertices
    mesh_data.faces = cube_faces

doc.saveas("cube_mesh_1.dxf")
Create a cube mesh by assembling single faces using the edit_data() context manager of the Mesh class and the helper class MeshData:

import ezdxf


# 8 corner vertices
p = [
    (0, 0, 0),
    (1, 0, 0),
    (1, 1, 0),
    (0, 1, 0),
    (0, 0, 1),
    (1, 0, 1),
    (1, 1, 1),
    (0, 1, 1),
]

# MESH requires DXF R2000 or later
doc = ezdxf.new("R2000")
msp = doc.modelspace()
mesh = msp.add_mesh()

with mesh.edit_data() as mesh_data:
    mesh_data.add_face([p[0], p[1], p[2], p[3]])
    mesh_data.add_face([p[4], p[5], p[6], p[7]])
    mesh_data.add_face([p[0], p[1], p[5], p[4]])
    mesh_data.add_face([p[1], p[2], p[6], p[5]])
    mesh_data.add_face([p[3], p[2], p[6], p[7]])
    mesh_data.add_face([p[0], p[3], p[7], p[4]])
    # optional call optimize(): minimizes the vertex count
    mesh_data.optimize()

doc.saveas("cube_mesh_2.dxf")
Its recommended to use the MeshBuilder objects to create 3D meshes and render them as MESH entities by the render_mesh() method into a layout:

import ezdxf
from ezdxf import colors
from ezdxf.gfxattribs import GfxAttribs
from ezdxf.render import forms

cube = forms.cube().scale_uniform(10).subdivide(2)
red = GfxAttribs(color=colors.RED)
green = GfxAttribs(color=colors.GREEN)
blue = GfxAttribs(color=colors.BLUE)

doc = ezdxf.new()
msp = doc.modelspace()

# render as MESH entity
cube.render_mesh(msp, dxfattribs=red)
cube.translate(20)

# render as POLYFACE a.k.a. POLYLINE entity
cube.render_polyface(msp, dxfattribs=green)
cube.translate(20)

# render as a bunch of 3DFACE entities
cube.render_3dfaces(msp, dxfattribs=blue)

doc.saveas("meshes.dxf")
../_images/mesh_cubes.png
There exist some tools to manage meshes:

ezdxf.render.MeshBuilder: The MeshBuilder classes are helper tools to manage meshes buildup by vertices and faces.

ezdxf.render.MeshTransformer: Same functionality as MeshBuilder but supports inplace transformation.

ezdxf.render.MeshDiagnose: A diagnose tool which can be used to analyze and detect errors of MeshBuilder objects like topology errors for closed surfaces.

ezdxf.render.FaceOrientationDetector: A helper class for face orientation and face normal vector detection

The ezdxf.render.forms module provides function to create basic geometries like cube, cone, sphere and so on and functions to create meshes from profiles by extrusion, rotation or sweeping.

This example shows how to sweep a gear profile along a helix:

import ezdxf
from ezdxf.render import forms

doc = ezdxf.new()
doc.layers.add("MESH", color=ezdxf.colors.YELLOW)
msp = doc.modelspace()
# sweeping a gear-profile
gear = forms.gear(
    8, top_width=0.01, bottom_width=0.02, height=0.02, outside_radius=0.1
)
helix = path.helix(radius=2, pitch=1, turns=6)
# along a helix spine
sweeping_path = helix.flattening(0.1)
mesh = forms.sweep(gear, sweeping_path, close=True, caps=True)
# and render as MESH entity
mesh.render_mesh(msp, dxfattribs={"layer": "MESH"})
doc.saveas("gear_along_helix.dxf")
../_images/gear_along_helix.png
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/hatch_pattern.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Hatch Pattern Definition
Tutorial for Hatch Pattern Definition?
A hatch pattern consist of one or more hatch lines. A hatch line defines a set of lines which have the same orientation an the same line pattern. All the lines defined by a hatch line are parallel and have a constant distance to each other. The origin defines the start point of the hatch line and also the starting point of the line pattern. The direction defines the angle between the WCS x-axis and the hatch line. The offset is a 2D vector which will be added consecutively the the origin for each new hatch line. The line pattern has the same format as as the simple linetype pattern (Tutorial for Creating Linetype Pattern).

Important

The hatch pattern must be defined for a hatch scaling factor of 1.0 and a hatch rotation angle of 0 degrees!

The first example creates a simple pattern of horizontal solid lines with a vertical distance of 0.5 drawing units.

import ezdxf

doc = ezdxf.new("R2010")
msp = doc.modelspace()
hatch = msp.add_hatch()
hatch.set_pattern_fill(
    "MyPattern",
    color=7,
    angle=0,
    scale=1.0,
    style=0,  # normal hatching style
    pattern_type=0,  # user-defined
    # pattern definition as list of:
    # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
    # line pattern is a solid line
    definition=[[0, (0, 0), (0, 0.5), []]],

)
points = [(0, 0), (10, 0), (10, 10), (0, 10)]
hatch.paths.add_polyline_path(points)
msp.add_lwpolyline(points, close=True, dxfattribs={"color": 1})
doc.saveas("user_defined_hatch_pattern.dxf")
../_images/hatch_pattern_1.png
The next example shows how the offset value works:

# -x-x-x- snip -x-x-x-
hatch = msp.add_hatch()
hatch.set_pattern_fill(
    "MyPattern",
    color=7,
    angle=0,
    scale=1.0,
    style=0,  # normal hatching style
    pattern_type=0,  # user-defined
    # the line pattern is a dashed line:  - - - -
    # the offset is 1 unit vertical and 0.3 units horizontal
    # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
    definition=[[0, (0, 0), (0.3, 1), [1, -1]]],

)
# -x-x-x- snip -x-x-x-
../_images/hatch_pattern_2.png
The next example combines two parallel hatch lines, the origin defines how the hatch lines are offset from each other:

# -x-x-x- snip -x-x-x-
hatch = msp.add_hatch()
hatch.set_pattern_fill(
    "MyPattern",
    color=7,
    angle=0,
    scale=1.0,
    style=0,  # normal hatching style
    pattern_type=0,  # user-defined
    # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
    definition=[
        [0, (0, 0), (0.3, 1), [1, -1]],  # dashed line
        [0, (0, 0.5), (0, 1), []],  # solid line
    ],
)
# -x-x-x- snip -x-x-x-
../_images/hatch_pattern_3.png
The next example combines two hatch lines with different angles. The origins can be the same for this example. The Vec2 class is used to calculate the offset value for a normal distance of 0.7 drawing units between the slanted lines:

from ezdxf.math import Vec2

# -x-x-x- snip -x-x-x-
hatch = msp.add_hatch()
# offset vector for a normal distance of 0.7 for a 45 deg slanted hatch line
offset = Vec2.from_deg_angle(45 + 90, length=0.7)
hatch.set_pattern_fill(
    "MyPattern",
    color=7,
    angle=0,
    scale=1.0,
    style=0,  # normal hatching style
    pattern_type=0,  # user-defined
    # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
    definition=[
        [0, (0, 0), (0, 1), [1, -1]],  # horizontal dashed line
        [45, (0, 0), offset, []],  # slanted solid line
    ],
)
# -x-x-x- snip -x-x-x-
../_images/hatch_pattern_4.png
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/mleader.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
MTEXT Quick Draw
Create MTEXT Content
MTEXT Connection Types
MTEXT Alignment
Create BLOCK Content
BLOCK Connection Types
BLOCK Alignment
BLOCK Scaling
BLOCK Rotation
BLOCK Attributes
Leader Properties
Dogleg Properties
Polyline Leader
Spline Leader
Line Styling
Arrowheads
Overall Scaling
Setup MLEADERSTYLE
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for MultiLeader
Tutorial for MultiLeader?
A multileader object typically consists of an arrowhead, a horizontal landing (a.k.a. dogleg ), a leader line or curve, and either a MTEXT object or a BLOCK.

Factory methods of the BaseLayout class to create new MultiLeader entities:

add_multileader_mtext()

add_multileader_block()

Because of the complexity of the MULTILEADER entity, the factory method add_multileader_mtext() returns a MultiLeaderMTextBuilder instance to build a new entity and the factory method add_multileader_block() returns a MultiLeaderBlockBuilder instance.

Due of the lack of good documentation it s not possible to support all combinations of MULTILEADER properties with decent quality, so stick to recipes and hints shown in this tutorial to get usable results otherwise, you will enter uncharted territory.

The rendering result of the MULTILEADER entity is highly dependent on the CAD application. The MULTILEADER entity does not have a pre-rendered anonymous block of DXF primitives like all DIMENSION entities, so results may vary from CAD application to CAD application. The general support for this entity is only good in Autodesk products other CAD applications often struggle when rendering MULTILEADERS, even my preferred testing application BricsCAD has rendering issues.

Important

MULTILEADER support has flaws in many CAD applications except Autodesk products!

See also

ezdxf.render.MultiLeaderBuilder classes

ezdxf.entities.MultiLeader class

ezdxf.entities.MLeaderStyle class

ezdxf.tools.text.MTextEditor class

MULTILEADER Internals

MTEXT Quick Draw?
Full Python script: mtext_quick_leader.py

The quick_leader() method of a MTEXT - MULTILEADER entity constructs the geometry parameters in reverse manner, starting from a given target point:

DXF document setup:

    doc = ezdxf.new(setup=True)
    # Create a new custom MLEADERSTYLE:
    mleaderstyle = doc.mleader_styles.duplicate_entry("Standard", "EZDXF")
    # The required TEXT style "OpenSans" was created by ezdxf.new() because setup is True:
    mleaderstyle.set_mtext_style("OpenSans")
    msp = doc.modelspace()
Draw a red circle to mark the target point:

    target_point = Vec2(40, 15)
    msp.add_circle(
        target_point, radius=0.5, dxfattribs=GfxAttribs(color=colors.RED)
    )
Create four horizontal placed MULTILEADER entities pointing at the target point, the first segment of the leader line is determined by an angle in this example pointing away from the target point:

    for angle in [45, 135, 225, -45]:
        ml_builder = msp.add_multileader_mtext("EZDXF")
        ml_builder.quick_leader(
            f"angle={angle} \n2nd text line",
            target=target_point,
            segment1=Vec2.from_deg_angle(angle, 14),
        )
../_images/mleader_mtext_quick_leader_0.png
The content is automatically aligned to the end of the leader line. The first segment is a relative vector to the target point and the optional second segment vector is relative to the end of the first segment. The default connection type is horizontal but can be changed to vertical:

A smaller text size is required:

    mleaderstyle = doc.mleader_styles.duplicate_entry("Standard", "EZDXF")
    mleaderstyle.set_mtext_style("OpenSans")
    mleaderstyle.dxf.char_height = 2.0  # set the default char height of MTEXT
Adding vertical placed MULTILEADER entities:

    for angle in [45, 135, 225, -45]:
        ml_builder = msp.add_multileader_mtext("EZDXF")
        ml_builder.quick_leader(
            f"angle={angle} \n2nd text line",
            target=target_point,
            segment1=Vec2.from_deg_angle(angle, 14),
            connection_type=mleader.VerticalConnection.center_overline,
        )
This example already shows the limitation caused by different text renderings in various CAD applications. The ezdxf text measurement by matplotlib is different to AutoCAD and BricsCAD and the result is a misalignment of the overline and the leader line.

The DXF file shown in BricsCAD:

../_images/mleader_mtext_quick_leader_1.png
The same DXF file shown with the ezdxf view command (drawing add-on):

../_images/mleader_mtext_quick_leader_2.png
My advice is to avoid vertical placed MULTILEADER entities at all and for horizontal placed MULTILEADER entities avoid styles including an underline or an overline .

The quick_leader() method is not very customizable for ease of use, but follows the settings of the associated MLeaderStyle.

The following sections show how to have more control when adding MULTILEADER entities.

Create MTEXT Content?
Full Python script: mtext_content.py

This section shows how to create a MULTILEADER entity with MTEXT content the manual way with full control over all settings.

For good results the MTEXT alignment should match the leader connection side, e.g. if you attach leaders to the left side also align the MTEXT to the left side, for leaders attached at the right side, align the MTEXT to the right side and if you attach leaders at both sides one side will fit better than the other or maybe a center aligned MTEXT is a good solution, for further details see section MTEXT Alignment.

The first example uses the default connection type of the MLEADERSTYLE Standard which is middle of the top line for left and right attached leaders. The render UCS for this example is the WCS to keep things simple.

Create a new MULTILEADER entity.

    ml_builder = msp.add_multileader_mtext("Standard")
Set MTEXT content, text style and alignment.

    ml_builder.set_content(
        "Line1\nLine2",
        style="OpenSans",
        alignment=mleader.TextAlignment.left,  # set MTEXT alignment!
    )
Add the first leader on the left side. The leader points always to the first given vertex and all vertices are given in render UCS coordinates (= WCS in this example).

    ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])
More than one vertex per leader can be used:

    ml_builder.add_leader_line(
        mleader.ConnectionSide.left,
        [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
    )
The insert point of the build() method is the alignment point for the MTEXT content.

    ml_builder.build(insert=Vec2(5, 0))
The dogleg settings are defined by the MLEADERSTYLE Standard .

../_images/mleader_mtext_left.png
This example shows a leader attached to the right side and the MTEXT aligned to the right side.

    ml_builder = msp.add_multileader_mtext("Standard")
    ml_builder.set_content(
        "Line1\nLine2",
        style="OpenSans",
        alignment=mleader.TextAlignment.right,  # set MTEXT alignment!
    )
    ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
    ml_builder.build(insert=Vec2(15, 0))
../_images/mleader_mtext_right.png
This example shows two leaders attached to both sides and the MTEXT aligned to the left side, which shows that the right landing gap (space between text and start of vertex) is bigger than the gap on the left size. This is due to the different text size calculations from AutoCAD/BricsCAD and Matplotlib. The longer the text, the greater the error.

    ml_builder = msp.add_multileader_mtext("Standard")
    ml_builder.set_content(
        "Line1\nLine1",
        style="OpenSans",
        alignment=mleader.TextAlignment.left,  # set MTEXT alignment!
    )
    ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])
    ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
    ml_builder.build(insert=Vec2(5, 0))
../_images/mleader_mtext_left_right_1.png
A centered MTEXT alignment gives a more even result.

    ml_builder = msp.add_multileader_mtext("Standard")
    ml_builder.set_content(
        "First Line\n2. Line",
        style="OpenSans",
        alignment=mleader.TextAlignment.center,  # set MTEXT alignment!
    )
    ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])
    ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
    ml_builder.build(insert=Vec2(10, 0))
../_images/mleader_mtext_left_right_2.png
But even this has its disadvantages, the attachment calculation is always based on the bounding box of the MTEXT content.

../_images/mleader_mtext_left_right_3.png
MTEXT Connection Types?
There are four connection sides defined by the enum ezdxf.render.ConnectionSide:

left

right

top

bottom

The MultiLeader entity supports as the name says multiple leader lines, but all have to have a horizontal (left/right) connection side or a vertical (top/bottom) connection side, it s not possible to mix left/right and top/bottom connection sides. This is determined by the DXF format.

There are different connection types available for the horizontal and the vertical connection sides. All leaders connecting to the same side have the same connection type. The horizontal connection sides support following connection types, defined by the enum ezdxf.render.HorizontalConnection:

by_style

top_of_top_line

middle_of_top_line

middle_of_text

middle_of_bottom_line

bottom_of_bottom_line

bottom_of_bottom_line_underline (not recommended)

bottom_of_top_line_underline (not recommended)

bottom_of_top_line

bottom_of_top_line_underline_all (not recommended)

The vertical connection sides support following connection types, defined by the enum ezdxf.render.VerticalConnection:

by_style

center

center_overline (not recommended)

The connection type for each side can be set by the method set_connection_types(), the default for all sides is by_style:

    ml_builder.set_connection_types(
        left=mleader.HorizontalConnection.middle_of_top_line,
        right=mleader.HorizontalConnection.middle_of_bottom_line,
    )
../_images/mleader_mtext_horiz_connection_types.png
Hint

As shown in the quick draw section using connection types including underlines or overlines do not render well in AutoCAD/BricsCAD because of the different text measurement of matplotlib, therefore it s not recommended to use any of these connection types when creating MULTILEADERS by ezdxf.

MTEXT Alignment?
In contrast to the standalone MTEXT entity supports the MTEXT content entity only three text alignments defined by the enum ezdxf.render.TextAlignment.

left

center

right

The MTEXT alignment is set as argument alignment of the set_content() method and the alignment point is the insert point of the build() method.

Create BLOCK Content?
Full Python script: block_content.py

This section shows how to create a MULTILEADER entity with BLOCK content the manual way with full control over all settings.

The BLOCK content consist of a BLOCK layout and optional ATTDEF entities which defines the location and DXF attributes of dynamically created ATTRIB entities.

Create the BLOCK content, the full create_square_block() function can be found in the block_content.py script.

    block = create_square_block(
        doc, size=8.0, margin=0.25, base_point=base_point
    )
Create the MULTILEADER and set the content:

    ml_builder = msp.add_multileader_block(style="Standard")
    ml_builder.set_content(
        name=block.name, alignment=mleader.BlockAlignment.insertion_point
    )
Set the BLOCK attribute content as text:

    ml_builder.set_attribute("ONE", "Data1")
    ml_builder.set_attribute("TWO", "Data2")
Add some leader lines to the left and right side of the BLOCK:

Construction plane of the entity is defined by a render UCS. The leader lines vertices are expected in render UCS coordinates, which means relative to the UCS origin and this example shows the simple case where the UCS is the WCS which is also the default setting.

    ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(x2, y1)])
    ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(x2, y2)])
    ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(x1, y1)])
    ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(x1, y2)])
Last step is to build the final MULTILEADER entity. This example uses the alignment type insertion_point where the insert point of the build() method is the base point of the BLOCK:

    ml_builder.build(insert=Vec2(5, 2), rotation=30)
../_images/mleader_block_horiz_1.png
The result is shown in BricsCAD as expected, although BricsCAD shows Center extents as attachment type in the properties dialog instead of the correct attachment type Insertion point .

BLOCK Connection Types?
There are four connection sides defined by the enum ezdxf.render.ConnectionSide:

left

right

top

bottom

The connection point for leader lines is always the center of the side of the block bounding box the leader is connected to and has the same limitation as for the MTEXT content, it s not possible to mix the connection sides left/right and top/bottom.

The connection side is set when adding the leader line by the add_leader_line() method.

Unfortunately BricsCAD has an error in version 22.2.03 and renders all connection types as left/right, this is top/bottom connection shown in Autodesk TrueView 2022:

../_images/mleader_block_vertical_1.png
The top/bottom connection type does not support the dogleg feature.

BLOCK Alignment?
There are two alignments types, defined by the enum ezdxf.render.BlockAlignment

center_extents

insertion_point

The alignment is set by the set_content() method.

The alignment type center_extent inserts the BLOCK with the center of the bounding box at the insert point of the build() method. The insert point is (5, 2) in this example:

../_images/mleader_block_horiz_2.png
The same MULTILEADER with alignment type insert_point:

../_images/mleader_block_horiz_1.png
BLOCK Scaling?
The BLOCK content can be scaled independently from the overall scaling of the MULTILEADER entity:

The block scaling factor is set by the set_content() method:

ml_builder.set_content(
    name=block.name, scale=2.0, alignment=mleader.BlockAlignment.center_extents
)
This is the first example with a block scaling factor of 2. The BLOCK and the attached ATTRIB entities are scaled but not the arrows.

../_images/mleader_block_horiz_3.png
BLOCK Rotation?
The rotation around the render UCS z-axis in degrees is applied by the build() method:

ml_builder.build(insert=Vec2(5, 2), rotation=30)
This is the first example with a rotation of 30 degrees. The BLOCK, the attached ATTRIB entities and the last connection lines ( dogleg ) are rotated.

../_images/mleader_block_rotated.png
BLOCK Attributes?
BLOCK attributes are defined as ATTDEF entities in the BLOCK layout. This ATTDEF entities will be replaced by ATTRIB entities at the rendering process of the CAD application. Only the text content and the text width factor can be changed for each MULTILEADER entity individually by the set_attribute() method. The ATTDEF is addressed by it s DXF tag attribute:

ml_builder.set_attribute("ONE", "Data1")
ml_builder.set_attribute("TWO", "Data2")
Leader Properties?
Dogleg Properties?
The dogleg is the last line segment from the last leader vertex to the MULTILEADER content for polyline leaders.

../_images/mleader_landing_props.png
The length of the dogleg and the landing gap size is set by the set_connection_properties().

Polyline Leader?
A polygon leader line has only straight line segments and is added by the add_leader_line():

ml_builder.add_leader_line(
    mleader.ConnectionSide.left,
    [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
)
../_images/mleader_polyline_leader.png
All leader line vertices have render UCS coordinates and the start- and end-vertex of the dogleg is calculated automatically.

Spline Leader?
A spline leader line has a single curved line as leader line and is also added by the add_leader_line(). This is spline leader has the same vertices as the previous created polyline leader:

ml_builder.set_leader_properties(leader_type=mleader.LeaderType.splines)
ml_builder.add_leader_line(
    mleader.ConnectionSide.left,
    [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
)
../_images/mleader_spline_leader.png
The spline leader has no dogleg and spline leaders and polyline leaders can not be mixed in a single MULTILEADER entity.

The leader type is set by the set_leader_properties() method.

The LeaderType enum:

none

straight_lines

splines

Line Styling?
The leader color, linetype and lineweight is set by the set_leader_properties() method:

ml_builder.set_leader_properties(
    color=colors.MAGENTA,
    linetype="DASHEDX2",
    lineweight=70,
)
../_images/mleader_line_properties.png
All leader lines have the same properties.

Arrowheads?
The arrow head is set by the set_arrow_properties() method:

from ezdxf.render import ARROWS
ml_builder.set_arrow_properties(name=ARROWS.closed_blank, size=8.0)
../_images/mleader_arrow.png
All leader lines have the same arrow head and size. The available arrow heads are defined in the ARROWS object.

Overall Scaling?
The overall scaling has to be applied by the set_overall_scaling() method and scales the MTEXT or BLOCK content and the arrows.

Setup MLEADERSTYLE?
The MLeaderStyle stores many of the MULTILEADER settings but most of them are copied to the MULTILINE entity at initialization. So changing the MLEADERSTYLE style afterwards has little to no effect for existing MULTILEADER entities.

Create a new MLEADERSTYLE called MY_STYLE and set the MTEXT style to OpenSans :

my_style = doc.mleader_styles.duplicate_entry("Standard", "MY_STYLE")
my_style.set_mtext_style("OpenSans")
The style for a MULTILEADER is set at the add_multileader_mtext() and add_multileader_block() factory methods.

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/ucs_transformations.html ===== [Fetch failed] ===== https://ezdxf.readthedocs.io/en/stable/tutorials/radius_dimension.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Placing Measurement Text
Default Text Locations Outside
Default Text Locations Inside
User Defined Text Locations
Center Mark/Lines
Overriding Measurement Text
Measurement Text Formatting and Styling
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Radius Dimensions
Tutorial for Radius Dimensions?
Please read the Tutorial for Linear Dimensions before, if you haven t.

Note

Ezdxf does not consider all DIMSTYLE variables, so the rendering results are different from CAD applications.

import ezdxf

# DXF R2010 drawing, official DXF version name: 'AC1024',
# setup=True setups the default dimension styles
doc = ezdxf.new("R2010", setup=True)

msp = doc.modelspace()  # add new dimension entities to the modelspace
msp.add_circle((0, 0), radius=3)  # add a CIRCLE entity, not required
# add default radius dimension, measurement text is located outside
dim = msp.add_radius_dim(
    center=(0, 0), radius=3, angle=45, dimstyle="EZ_RADIUS"
)
# necessary second step, to create the BLOCK entity with the dimension geometry.
dim.render()
doc.saveas("radius_dimension.dxf")
The example above creates a 45 degrees slanted radius Dimension entity, the default dimension style EZ_RADIUS is defined as 1 drawing unit = 1m, drawing scale = 1:100 and the length factor = 100, which creates a measurement text in cm, the default location for the measurement text is outside of the circle.

The center point defines the center of the circle but there doesn t have to exist a circle entity, radius defines the circle radius, which is also the measurement, and angle defines the slope of the dimension line, it is also possible to define the circle by a measurement point mpoint on the circle.

The return value dim is not a dimension entity, instead a DimStyleOverride object is returned, the dimension entity is stored as dim.dimension.

Placing Measurement Text?
There are different predefined DIMSTYLES to achieve various text placing locations.

The basic DIMSTYLE EZ_RADIUS settings are:

1 drawing unit = 1m

scale 1:100

the length factor dimlfac = 100, which creates a measurement text in cm.

uses a closed filled arrow, arrow size dimasz = 0.25

Note

Not all possibles features of DIMSTYLE are supported by the ezdxf rendering procedure and especially for the radial dimension there are less features implemented than for the linear dimension because of the lack of good documentation.

See also

Graphical reference of many DIMVARS and some advanced information: DIMSTYLE Table

Source code file standards.py shows how to create your own DIMSTYLES.

The Script dimension_radius.py shows examples for radius dimensions.

Default Text Locations Outside?
Advanced EZ_RADIUS settings for placing the text outside of the circle:

tmove

1 = add a leader when dimension text is moved, this is the best setting for text outside to preserve the appearance of the DIMENSION entity, if editing afterwards in a CAD application.

dimtad

1 = place the text vertical above the dimension line

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS"
)
dim.render()  # always required, but not shown in the following examples
../_images/dim_radial_outside.png
To force text outside horizontal set dimtoh to 1:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS",
    override={"dimtoh": 1}
)
../_images/dim_radial_outside_horiz.png
Default Text Locations Inside?
DIMSTYLE EZ_RADIUS_INSIDE can be used to place the dimension text inside the circle at a default location.

The basic DIMSTYLE EZ_RADIUS_INSIDE settings are:

1 drawing unit = 1m

scale 1:100, length_factor is 100 which creates

the length factor dimlfac = 100, which creates a measurement text in cm.

uses a closed filled arrow, arrow size dimasz = 0.25

Advanced EZ_RADIUS_INSIDE settings to place (force) the text inside of the circle:

tmove

0 = moves the dimension line with dimension text, this is the best setting for text inside to preserve the appearance of the DIMENSION entity, if editing afterwards in a CAD application.

dimtix

1 = force text inside

dimatfit

0 = force text inside, required by BricsCAD and AutoCAD

dimtad

0 = center text vertical, BricsCAD and AutoCAD always create a vertical centered text, ezdxf let you choose the vertical placement (above, below, center), but editing the DIMENSION in BricsCAD or AutoCAD will reset text to center placement.

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS_INSIDE"
)
../_images/dim_radial_inside_0.png ../_images/dim_radial_inside_1.png
To force text inside horizontal set dimtih to 1:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS_INSIDE",
    override={"dimtih": 1}
)
../_images/dim_radial_inside_horiz.png
User Defined Text Locations?
Beside the default location it is always possible to override the text location by a user defined location. This location also determines the angle of the dimension line and overrides the argument angle. For user defined locations it is not necessary to force text inside (dimtix=1), because the location of the text is explicit given, therefore the DIMSTYLE EZ_RADIUS can be used for all this examples.

User defined location outside of the circle:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    location=(4, 4),
    dimstyle="EZ_RADIUS"
)
../_images/dim_radial_user_outside.png
User defined location outside of the circle and forced horizontal text:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    location=(4, 4),
    dimstyle="EZ_RADIUS",
    override={"dimtoh": 1}
)
../_images/dim_radial_user_outside_horiz.png
User defined location inside of the circle:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    location=(1, 1),
    dimstyle="EZ_RADIUS"
)
../_images/dim_radial_user_inside_0.png ../_images/dim_radial_user_inside_2.png
User defined location inside of the circle and forced horizontal text:

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    location=(1, 1),
    dimstyle="EZ_RADIUS",
    override={"dimtih": 1},
)
../_images/dim_radial_user_inside_horiz.png
Center Mark/Lines?
Center mark/lines are controlled by dimcen, default value is 0 for predefined dimstyles EZ_RADIUS and EZ_RADIUS_INSIDE :

0

Center mark is off

>0

Create center mark of given size

<0

Create center lines

dim = msp.add_radius_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS",
    override={"dimcen": 0.25},
)
../_images/dim_center_mark.png
Overriding Measurement Text?
See Linear Dimension Tutorial: Overriding Measurement Text

Measurement Text Formatting and Styling?
See Linear Dimension Tutorial: Measurement Text Formatting and Styling

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/diameter_dimension.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Placing Measurement Text
Default Text Locations Outside
Default Text Locations Inside
User Defined Text Locations
Center Mark/Lines
Overriding Measurement Text
Measurement Text Formatting and Styling
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Diameter Dimensions
Tutorial for Diameter Dimensions?
Please read the Tutorial for Radius Dimensions before, if you haven t.

Note

Ezdxf does not consider all DIMSTYLE variables, so the rendering results are different from CAD applications.

This is a repetition of the radius tutorial, just with diameter dimensions.

import ezdxf

# setup=True setups the default dimension styles
doc = ezdxf.new("R2010", setup=True)

msp = doc.modelspace()  # add new dimension entities to the modelspace
msp.add_circle((0, 0), radius=3)  # add a CIRCLE entity, not required
# add default diameter dimension, measurement text is located outside
dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=3,
    angle=45,
    dimstyle="EZ_RADIUS"
)
dim.render()
doc.saveas("diameter_dimension.dxf")
The example above creates a 45 degrees slanted diameter Dimension entity, the default dimension style EZ_RADIUS (same as for radius dimensions) is defined as 1 drawing unit = 1m, drawing scale = 1:100 and the length factor = 100, which creates a measurement text in cm, the default location for the measurement text is outside of the circle.

The center point defines the center of the circle but there doesn t have to exist a circle entity, radius defines the circle radius and angle defines the slope of the dimension line, it is also possible to define the circle by a measurement point mpoint on the circle.

The return value dim is not a dimension entity, instead a DimStyleOverride object is returned, the dimension entity is stored as dim.dimension.

Placing Measurement Text?
There are different predefined DIMSTYLES to achieve various text placing locations.

The basic DIMSTYLE EZ_RADIUS settings are:

1 drawing unit = 1m

scale 1:100

the length factor dimlfac = 100, which creates a measurement text in cm.

uses a closed filled arrow, arrow size dimasz = 0.25

Note

Not all possibles features of DIMSTYLE are supported by the ezdxf rendering procedure and especially for the diameter dimension there are less features implemented than for the linear dimension because of the lack of good documentation.

See also

Graphical reference of many DIMVARS and some advanced information: DIMSTYLE Table

Source code file standards.py shows how to create your own DIMSTYLES.

The Script dimension_diameter.py shows examples for radius dimensions.

Default Text Locations Outside?
EZ_RADIUS default settings for to place text outside:

tmove

1 = add a leader when dimension text is moved, this is the best setting for text outside to preserve the appearance of the DIMENSION entity, if editing afterwards in a CAD application.

dimtad

1 = place the text vertical above the dimension line

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS"
)
dim.render()  # always required, but not shown in the following examples
../_images/dim_diameter_outside.png
To force text outside horizontal set dimtoh to 1:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS",
    override={"dimtoh": 1}
)
../_images/dim_diameter_outside_horiz.png
Default Text Locations Inside?
DIMSTYLE EZ_RADIUS_INSIDE can be used to place the dimension text inside the circle at a default location.

The basic DIMSTYLE settings are:

1 drawing unit = 1m

scale 1:100, length_factor is 100 which creates

the length factor dimlfac = 100, which creates a measurement text in cm.

uses a closed filled arrow, arrow size dimasz = 0.25

Advanced EZ_RADIUS_INSIDE settings to place (force) the text inside of the circle:

tmove

0 = moves the dimension line with dimension text, this is the best setting for text inside to preserve the appearance of the DIMENSION entity, if editing afterwards in a CAD application.

dimtix

1 = force text inside

dimatfit

0 = force text inside, required by BricsCAD and AutoCAD

dimtad

0 = center text vertical, BricsCAD and AutoCAD always create a vertical centered text, ezdxf let you choose the vertical placement (above, below, center), but editing the DIMENSION in BricsCAD or AutoCAD will reset text to center placement.

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS_INSIDE"
)
../_images/dim_diameter_inside.png
To force text inside horizontal set dimtih to 1:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    angle=45,
    dimstyle="EZ_RADIUS_INSIDE",
    override={"dimtih": 1}
)
../_images/dim_diameter_inside_horiz.png
User Defined Text Locations?
Beside the default location it is always possible to override the text location by a user defined location. This location also determines the angle of the dimension line and overrides the argument angle. For user defined locations it is not necessary to force text inside (dimtix=1), because the location of the text is explicit given, therefore the DIMSTYLE EZ_RADIUS can be used for all this examples.

User defined location outside of the circle:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    location=(4, 4),
    dimstyle="EZ_RADIUS"
)
../_images/dim_diameter_user_outside.png
User defined location outside of the circle and forced horizontal text:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    location=(4, 4),
    dimstyle="EZ_RADIUS",
    override={"dimtoh": 1}
)
../_images/dim_diameter_user_outside_horiz.png
User defined location inside of the circle:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    location=(1, 1),
    dimstyle="EZ_RADIUS"
)
../_images/dim_diameter_user_inside.png
User defined location inside of the circle and forced horizontal text:

dim = msp.add_diameter_dim(
    center=(0, 0),
    radius=2.5,
    location=(1, 1),
    dimstyle="EZ_RADIUS",
    override={"dimtih": 1},
)
../_images/dim_diameter_user_inside_horiz.png
Center Mark/Lines?
See Radius Dimension Tutorial: Center Mark/Lines

Overriding Measurement Text?
See Linear Dimension Tutorial: Overriding Measurement Text

Measurement Text Formatting and Styling?
See Linear Dimension Tutorial: Measurement Text Formatting and Styling

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/angular_dimension.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Dimension Style EZ_CURVED
Factory Methods to Create Angular Dimensions
Defined by Center, Radius and Angles
Angle by 2 Lines
Angle by 3 Points
Angle from ConstructionArc
Placing Measurement Text
Default Text Locations
Shift Text From Default Location
User Defined Text Locations
Overriding Text Rotation
Angular Units
Overriding Measurement Text
Measurement Text Formatting and Styling
Tolerances and Limits
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Angular Dimensions
Tutorial for Angular Dimensions?
Please read the Tutorial for Linear Dimensions before, if you haven t.

Note

Ezdxf does not consider all DIMSTYLE variables, so the rendering results are different from CAD applications.

Dimension Style EZ_CURVED ?
All factory methods to create angular dimensions uses the dimension style EZ_CURVED for curved dimension lines which is defined as:

angle unit is decimal degrees, dimaunit = 0

measurement text height = 0.25 (drawing scale = 1:100)

measurement text location is above the dimension line

closed filled arrow and arrow size dimasz = 0.25

dimazin = 2, suppresses trailing zeros (e.g. 12.5000 becomes 12.5)

This DIMENSION style only exist if the argument setup is True for creating a new DXF document by ezdxf.new(). Every dimension style which does not exist will be replaced by the dimension style Standard at DXF export by save() or saveas() (e.g. dimension style setup was not initiated).

Add all ezdxf specific resources (line types, text- and dimension styles) to an existing DXF document:

import ezdxf
from ezdxf.tools.standards import setup_drawing

doc = ezdxf.readfile("your.dxf")
setup_drawing(doc, topics="all")
Factory Methods to Create Angular Dimensions?
Defined by Center, Radius and Angles?
The first example shows an angular dimension defined by the center point, radius, start- and end angles:

import ezdxf

# Create a DXF R2010 document:
# Use argument setup=True to setup the default dimension styles.
doc = ezdxf.new("R2010", setup=True)

# Add new entities to the modelspace:
msp = doc.modelspace()

# Add an angular DIMENSION defined by the center point, start- and end angles,
# the measurement text is placed at the default location above the dimension
# line:
dim = msp.add_angular_dim_cra(
    center=(5, 5),  # center point of the angle
    radius= 7,  # distance from center point to the start of the extension lines
    start_angle=60,  # start angle in degrees
    end_angle=120,  # end angle in degrees
    distance=3,  # distance from start of the extension lines to the dimension line
    dimstyle="EZ_CURVED",  # default angular dimension style
)

# Necessary second step to create the BLOCK entity with the dimension geometry.
# Additional processing of the DIMENSION entity could happen between adding
# the entity and the rendering call.
dim.render()
doc.saveas("angular_dimension_cra.dxf")
The return value dim is not a dimension entity, instead a DimStyleOverride object is returned, the dimension entity is stored as dim.dimension.

../_images/dim_angular_cra.png
Angle by 2 Lines?
The next example shows an angular dimension for an angle defined by two lines:

import ezdxf

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

# Setup the geometric parameters for the DIMENSION entity:
base = (5.8833, -6.3408)  # location of the dimension line
p1 = (2.0101, -7.5156)  # start point of 1st leg
p2 = (2.7865, -10.4133)  # end point of 1st leg
p3 = (6.7054, -7.5156)  # start point of 2nd leg
p4 = (5.9289, -10.4133)  # end point of 2nd leg

# Draw the lines for visualization, not required to create the
# DIMENSION entity:
msp.add_line(p1, p2)
msp.add_line(p3, p4)

# Add an angular DIMENSION defined by two lines, the measurement text is
# placed at the default location above the dimension line:
dim = msp.add_angular_dim_2l(
    base=base,  # defines the location of the dimension line
    line1=(p1, p2),  # start leg of the angle
    line2=(p3, p4),  # end leg of the angle
    dimstyle="EZ_CURVED",  # default angular dimension style
)

# Necessary second step to create the dimension line geometry:
dim.render()
doc.saveas("angular_dimension_2l.dxf")
The example above creates an angular Dimension entity to measures the angle between two lines (line1 and line2).

The base point defines the location of the dimension line (arc), any point on the dimension line is valid. The points p1 and p2 define the first leg of the angle, p1 also defines the start point of the first extension line. The points p3 and p4 define the second leg of the angle and point p3 also defines the start point of the second extension line.

The measurement of the DIMENSION entity is the angle enclosed by the first and the second leg and where the dimension line passes the base point.

../_images/dim_angular_2l.png
Angle by 3 Points?
The next example shows an angular dimension defined by three points, a center point and the two end points of the angle legs:

import ezdxf

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

msp.add_angular_dim_3p(
    base=(0, 7),  # location of the dimension line
    center=(0, 0),  # center point
    p1=(-3, 5),  # end point of 1st leg = start angle
    p2=(3, 5),  # end point of 2nd leg = end angle
).render()
../_images/dim_angular_3p.png
Angle from ConstructionArc?
The ezdxf.math.ConstructionArc provides various class methods for creating arcs and the construction tool can be created from an ARC entity.

Add an angular dimension to an ARC entity:

import ezdxf

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

arc = msp.add_arc(
    center=(0, 0),
    radius=5,
    start_angle = 60,
    end_angle = 120,
)
msp.add_angular_dim_arc(
    arc.construction_tool(),
    distance=2,
).render()
../_images/dim_angular_from_arc.png
Placing Measurement Text?
The default location of the measurement text depends on various DimStyle parameters and is applied if no user defined text location is defined.

Note

Not all possibles features of DIMSTYLE are supported by the ezdxf rendering procedure and especially for the angular dimension there are less features implemented than for the linear dimension because of the lack of good documentation.

See also

Graphical reference of many DIMVARS and some advanced information: DIMSTYLE Table

Source code file standards.py shows how to create your own DIMSTYLES.

The Script dimension_angular.py shows examples for angular dimensions.

Default Text Locations?
The DIMSTYLE EZ_CURVED places the measurement text in the center of the angle above the dimension line. The first examples above show the measurement text at the default text location.

The text direction angle is always perpendicular to the line from the text center to the center point of the angle unless this angle is manually overridden.

The vertical location of the measurement text relative to the dimension line is defined by dimtad:

0

Center, it is possible to adjust the vertical location by dimtvp

1

Above

2

Outside, handled like Above by ezdxf

3

JIS, handled like Above by ezdxf

4

Below

msp.add_angular_dim_cra(
    center=(3, 3),
    radius=3,
    distance=1,
    start_angle=60,
    end_angle=120,
    override={
        "dimtad": 1,  # 0=center; 1=above; 4=below;
    },
).render()
../_images/dim_angular_dimtad.png
Arrows and measurement text are placed outside automatically if the available space between the extension lines isn t sufficient. This overrides the dimtad value by 1 ( above ). Ezdxf follows its own rules, ignores the dimatfit attribute and works similar to dimatfit = 1, move arrows first, then text:

../_images/dim_angular_outside.png
Shift Text From Default Location?
The method shift_text() shifts the measurement text away from the default location. The shifting direction is aligned to the text rotation of the default measurement text.

dim = msp.add_angular_dim_cra(
    center=(3, 3),
    radius=3,
    distance=1,
    start_angle=60,
    end_angle=120,
)
# shift text from default text location:
dim.shift_text(0.5, 1.0)
dim.render()
../_images/dim_angular_shift_text.png
This is just a rendering effect, editing the dimension line in a CAD application resets the text to the default location.

User Defined Text Locations?
Beside the default location it is always possible to override the text location by a user defined location.

The coordinates of user locations are located in the rendering UCS and the default rendering UCS is the WCS.

Absolute User Location?
Absolute placing of the measurement text means relative to the origin of the render UCS. The user location is stored in the DIMENSION entity, which means editing the dimension line in a CAD application does not alter the text location. This location also determines the rotation of the measurement text.

dim = msp.add_angular_dim_cra(
    center=(3, 3),
    radius=3,
    distance=1,
    start_angle=60,
    end_angle=120,
    location=(5, 8),  # user defined measurement text location
)
dim.render()
../_images/dim_angular_user_location_1.png
Relative User Location?
Relative placing of the measurement text means relative to the middle of the dimension line. This is only possible by calling the set_location() method, and the argument relative has to be True. The user location is stored in the DIMENSION entity, which means editing the dimension line in a CAD application does not alter the text location. This location also determines the rotation of the measurement text.

dim = msp.add_angular_dim_cra(
    center=(3, 3),
    radius=3,
    distance=1,
    start_angle=60,
    end_angle=120,
)
dim.set_location((1, 2), relative=True)
dim.render()
../_images/dim_angular_user_location_2.png
Adding a Leader?
The method set_location() has the option to add a leader line to the measurement text. This also aligns the text rotation to the render UCS x-axis, this means in the default case the measurement text is horizontal. The leader line can be below the text or start at the left or right center of the text, this location is defined by the dimtad attribute, 0 means center and any value != 0 means below .

for dimtad, x in [(0, 0), (4, 6)]:
    dim = msp.add_angular_dim_cra(
        center=(3 + x, 3),
        radius=3,
        distance=1,
        start_angle=60,
        end_angle=120,
        override={"dimtad": dimtad}  # "center" == 0; "below" != 0;
    )
    dim.set_location((1, 2), relative=True, leader=True)
    dim.render()
../_images/dim_angular_user_location_3.png
Advanced version which calculates the relative text location: The user location vector has a length 2 and the orientation is defined by center_angle pointing away from the center of the angle.

import ezdxf
from ezdxf.math import Vec3

doc = ezdxf.new(setup=True)
msp = doc.modelspace()
for dimtad, y, leader in [
    [0, 0, False],
    [0, 7, True],
    [4, 14, True],
]:
    for x, center_angle in [
        (0, 0), (7, 45), (14, 90), (21, 135), (26, 225), (29, 270)
    ]:
        dim = msp.add_angular_dim_cra(
            center=(x, y),
            radius=3.0,
            distance=1.0,
            start_angle=center_angle - 15.0,
            end_angle=center_angle + 15.0,
            override={"dimtad": dimtad},
        )
        # The user location is relative to the center of the dimension line:
        usr_location = Vec3.from_deg_angle(angle=center_angle, length=2.0)
        dim.set_location(usr_location, leader=leader, relative=True)
        dim.render()
../_images/dim_angular_user_location_4.png
Overriding Text Rotation?
All factory methods supporting the argument text_rotation can override the measurement text rotation. The user defined rotation is relative to the render UCS x-axis (default is WCS).

This example uses a relative text location without a leader and forces the text rotation to 90 degrees:

for x, center_angle in [(7, 45), (14, 90), (21, 135)]:
    dim = msp.add_angular_dim_cra(
        center=(x, 0),
        radius=3.0,
        distance=1.0,
        start_angle=center_angle - 15.0,
        end_angle=center_angle + 15.0,
        text_rotation=90,  # vertical text
    )
    usr_location = Vec3.from_deg_angle(angle=center_angle, length=1.0)
    dim.set_location(usr_location, leader=False, relative=True)
    dim.render()
../_images/dim_angular_user_location_5.png
Angular Units?
Angular units are set by dimaunit:

0

Decimal degrees

1

Degrees/Minutes/Seconds, dimadec controls the shown precision

dimadec=0: 30

dimadec=2: 30 35

dimadec=4: 30 35 25

dimadec=7: 30 35 25.15

2

Grad

3

Radians

d1 = 15
d2 = 15.59031944
for x, (dimaunit, dimadec) in enumerate(
    [
        (0, 4),
        (1, 7),
        (2, 4),
        (3, 4),
    ]
):
    dim = msp.add_angular_dim_cra(
        center=(x * 4.0, 0.0),
        radius=3.0,
        distance=1.0,
        start_angle=90.0 - d1,
        end_angle=90.0 + d2,
        override={
            "dimaunit": dimaunit,
            "dimadec": dimadec,
        },
    )
    dim.render()
../_images/dim_angular_dimaunit.png ../_images/dim_angular_dms.png
Overriding Measurement Text?
See Linear Dimension Tutorial: Overriding Measurement Text

Measurement Text Formatting and Styling?
See Linear Dimension Tutorial: Measurement Text Formatting and Styling

Tolerances and Limits?
See Linear Dimension Tutorial: Tolerances and Limits

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/arc_dimension.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Dimension Style EZ_CURVED
Factory Methods to Create Arc Dimensions
Defined by Center, Radius and Angles
Arc by 3 Points
Angle from ConstructionArc
Placing Measurement Text
Default Text Locations
Shift Text From Default Location
User Defined Text Locations
Overriding Text Rotation
Overriding Measurement Text
Measurement Text Formatting and Styling
Tolerances and Limits
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Arc Dimensions
Tutorial for Arc Dimensions?
Please read the Tutorial for Linear Dimensions before, if you haven t. This is a repetition of the Tutorial for Angular Dimensions, because ezdxf reuses the angular dimension to render arc dimensions. This approach is very different to CAD applications, but also much less work.

Note

Ezdxf does not render the arc dimension like CAD applications and does not consider all DIMSTYLE variables, so the rendering results are very different from CAD applications.

Dimension Style EZ_CURVED ?
All factory methods to create arc dimensions uses the dimension style EZ_CURVED for curved dimension lines which is defined as:

angle unit is decimal degrees, dimaunit = 0

measurement text height = 0.25 (drawing scale = 1:100)

measurement text location is above the dimension line

closed filled arrow and arrow size dimasz = 0.25

dimzin = 2, suppresses trailing zeros (e.g. 12.5000 becomes 12.5)

dimarcsym = 2, disables the arc symbol, 0 renders only an open round bracket ( in front of the text and 1 for arc symbol above the text is not supported, renders like disabled

For more information go to: Dimension Style EZ_CURVED

Factory Methods to Create Arc Dimensions?
Defined by Center, Radius and Angles?
The first example shows an arc dimension defined by the center point, radius, start- and end angles:

import ezdxf

# Use argument setup=True to setup the default dimension styles.
doc = ezdxf.new(setup=True)

# Add new entities to the modelspace:
msp = doc.modelspace()

# Add an arc DIMENSION defined by the center point, start- and end angles,
# the measurement text is placed at the default location above the dimension
# line:
dim = msp.add_arc_dim_cra(
    center=(5, 5),  # center point of the angle
    radius=5,  # distance from center point to the start of the extension lines
    start_angle=60,  # start angle in degrees
    end_angle=120,  # end angle in degrees
    distance=2,  # distance from start of the extension lines to the dimension line
    dimstyle="EZ_CURVED",  # default angular dimension style
)

# Necessary second step to create the BLOCK entity with the dimension geometry.
# Additional processing of the DIMENSION entity could happen between adding
# the entity and the rendering call.
dim.render()
doc.saveas("arc_dimension_cra.dxf")
The return value dim is not a dimension entity, instead a DimStyleOverride object is returned, the dimension entity is stored as dim.dimension.

../_images/dim_arc_cra.png
Arc by 3 Points?
The next example shows an angular dimension defined by three points, a center point and the two end points of the angle legs, the first point defines the radius, the second point defines only the end angle, the distance from the center point is not relevant:

import ezdxf

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

msp.add_arc_dim_3p(
    base=(0, 7),  # location of the dimension line
    center=(0, 0),  # center point
    p1=(2.5, 4.330127018922193),  # 1st point of arc defines start angle and radius
    p2=(-2.5, 4.330127018922194),  # 2nd point defines the end angle
).render()
../_images/dim_arc_3p.png
Angle from ConstructionArc?
The ezdxf.math.ConstructionArc provides various class methods for creating arcs and the construction tool can be created from an ARC entity.

Add an angular dimension to an ARC entity:

import ezdxf

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

arc = msp.add_arc(
    center=(0, 0),
    radius=5,
    start_angle = 60,
    end_angle = 120,
)
msp.add_arc_dim_arc(
    arc.construction_tool(),
    distance=2,
).render()
Placing Measurement Text?
The default location of the measurement text depends on various DimStyle parameters and is applied if no user defined text location is defined.

Note

Not all possibles features of DIMSTYLE are supported by the ezdxf rendering procedure and especially for the arc dimension there are less features implemented than for the linear dimension because of the lack of good documentation. If the arc symbol is enabled (dimarcsym = 0) only an open round bracket ( is rendered in front of the measurement text!

See also

Graphical reference of many DIMVARS and some advanced information: DIMSTYLE Table

Source code file standards.py shows how to create your own DIMSTYLES.

The Script dimension_arc.py shows examples for angular dimensions.

Default Text Locations?
The DIMSTYLE EZ_CURVED places the measurement text in the center of the angle above the dimension line. The first examples above show the measurement text at the default text location.

The text direction angle is always perpendicular to the line from the text center to the center point of the angle unless this angle is manually overridden.

Arrows and measurement text are placed outside automatically if the available space between the extension lines isn t sufficient.

For more information go to: Default Text Locations

Shift Text From Default Location?
The method shift_text() shifts the measurement text away from the default location. The shifting direction is aligned to the text rotation of the default measurement text.

For more information go to: Shift Text From Default Location

User Defined Text Locations?
Beside the default location it is always possible to override the text location by a user defined location.

The coordinates of user locations are located in the rendering UCS and the default rendering UCS is the WCS.

For more information go to: User Defined Text Locations

Absolute User Location?
Absolute placing of the measurement text means relative to the origin of the render UCS.

For more information go to: User Defined Text Locations

Relative User Location?
Relative placing of the measurement text means relative to the middle of the dimension line.

For more information go to: User Defined Text Locations

Adding a Leader?
Add a leader line to the measurement text and set the text rotation to horizontal .

For more information go to: User Defined Text Locations

Overriding Text Rotation?
All factory methods supporting the argument text_rotation can override the measurement text rotation. The user defined rotation is relative to the render UCS x-axis (default is WCS).

For more information go to: User Defined Text Locations

Overriding Measurement Text?
See Linear Dimension Tutorial: Overriding Text Rotation

Measurement Text Formatting and Styling?
See Linear Dimension Tutorial: Measurement Text Formatting and Styling

Tolerances and Limits?
See Linear Dimension Tutorial: Tolerances and Limits

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/ordinate_dimension.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Local Coordinate System
Factory Methods to Create Ordinate Dimensions
Global Feature Location
Local Feature Location
Placing Measurement Text
Overriding Measurement Text
Measurement Text Formatting and Styling
Tolerances and Limits
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Ordinate Dimensions
Tutorial for Ordinate Dimensions?
Please read the Tutorial for Linear Dimensions before, if you haven t.

Note

Ezdxf does not consider all DIMSTYLE variables, so the rendering results are different from CAD applications.

Local Coordinate System?
Ordinate dimensioning is used when the x- and the y-coordinates from a location (feature), are the only dimensions necessary. The dimensions to each feature, originate from one datum location, called origin in this tutorial.

The local coordinate system (LCS) in which the measurement is done, is defined by the origin and the rotation angle around the z-axis in the rendering UCS, which is the WCS by default.

Factory Methods to Create Ordinate Dimensions?
All factory methods for creating ordinate dimensions expect global coordinates to define the feature location.

Global Feature Location?
The first example shows ordinate dimensions defined in the render UCS, in this example the WCS, this is how the DIMENSION entity expects the coordinates of the feature location:

import ezdxf
from ezdxf.math import Vec3
from ezdxf.render import forms

# Use argument setup=True to setup the default dimension styles.
doc = ezdxf.new(setup=True)

# Add new entities to the modelspace:
msp = doc.modelspace()
# Add a rectangle: width=4, height = 2.5, lower left corner is WCS(x=2, y=3)
origin = Vec3(2, 3)
msp.add_lwpolyline(
    forms.translate(forms.box(4, 2.5), origin),
    close=True
)

# Add an x-type ordinate DIMENSION with global feature locations:
msp.add_ordinate_x_dim(
    # lower left corner
    feature_location=origin + (0, 0),  # feature location in the WCS
    offset=(0, -2),  # end of leader, relative to the feature location
    origin=origin,
).render()
msp.add_ordinate_x_dim(
    # lower right corner
    feature_location=origin + (4, 0),  # feature location in the WCS
    offset=(0, -2),
    origin=origin,
).render()

# Add an y-type ordinate DIMENSION with global feature locations:
msp.add_ordinate_y_dim(
    # lower right corner
    feature_location=origin + (4, 0),  # feature location in the WCS
    offset=(2, 0),
    origin=origin,
).render()
msp.add_ordinate_y_dim(
    # upper right corner
    feature_location=origin + (4, 2.5),  # feature location in the WCS
    offset=(2, 0),
    origin=origin,
).render()

# Necessary second step to create the BLOCK entity with the dimension geometry.
# Additional processing of the DIMENSION entity could happen between adding
# the entity and the rendering call.
doc.saveas("ord_global_features.dxf")
The return value dim is not a dimension entity, instead a DimStyleOverride object is returned, the dimension entity is stored as dim.dimension.

../_images/dim_ord_global.png
Local Feature Location?
The previous examples shows that the calculation of the global feature location is cumbersome and it gets even more complicated for a rotated LCS.

This example shows how to use a render UCS for using locale coordinates to define the feature locations:

import ezdxf
from ezdxf.math import Vec3, UCS
from ezdxf.render import forms

doc = ezdxf.new(setup=True)
msp = doc.modelspace()

# Create a special DIMSTYLE for "vertical" centered measurement text:
dimstyle = doc.dimstyles.duplicate_entry("EZDXF", "ORD_CENTER")
dimstyle.dxf.dimtad = 0  # "vertical" centered measurement text

# Add a rectangle: width=4, height = 2.5, lower left corner is WCS(x=2, y=3),
# rotated about 30 degrees:
origin = Vec3(2, 3)
msp.add_lwpolyline(
    forms.translate(forms.rotate(forms.box(4, 2.5), 30), origin),
    close=True
)

# Define the rotated local render UCS.
# The origin is the lower-left corner of the rectangle and the axis are
# aligned to the rectangle edges:
# The y-axis "uy" is calculated automatically by the right-hand rule.
ucs = UCS(origin, ux=Vec3.from_deg_angle(30), uz=(0, 0, 1))

# Add a x-type ordinate DIMENSION with local feature locations:
# the origin is now the origin of the UCS, which is (0, 0) the default value of
# "origin" and the feature coordinates are located in the UCS:
msp.add_ordinate_x_dim(
    # lower left corner
    feature_location=(0, 0),  # feature location in the UCS
    offset=(0.25, -2),  # # leader with a "knee"
    dimstyle="ORD_CENTER",
).render(ucs=ucs)  # Important when using a render UCS!
msp.add_ordinate_x_dim(
    # lower right corner
    feature_location=(4, 0),  # feature location in the UCS
    offset=(0.25, -2),  # leader with a "knee"
    dimstyle="ORD_CENTER",
).render(ucs=ucs)  # Important when using a render UCS!

# Add a y-type ordinate DIMENSION with local feature coordinates:
msp.add_ordinate_y_dim(
    # lower right corner
    feature_location=(4, 0),  # feature location in the UCS
    offset=(2, 0.25),  # leader with a "knee"
    dimstyle="ORD_CENTER",
).render(ucs=ucs)  # Important when using a render UCS!
msp.add_ordinate_y_dim(
    # upper right corner
    feature_location=(4, 2.5),  # feature location in the UCS
    offset=(2, 0.25),  # leader with a "knee"
    dimstyle="ORD_CENTER",
).render(ucs=ucs)  # Important when using a render UCS!
doc.saveas("ord_local_features.dxf")
../_images/dim_ord_local.png
Placing Measurement Text?
The ezdxf ordinate DIMENSION renderer places the measurement text always at the default location, because the location of the leader end point is given by the argument offset in the factory methods, which provides a flexible way to place the measurement text, overriding the text location by an explicit user location is not supported, also the user text rotation is not supported, the text is always aligned to the local coordinate system x- and y-axis.

See also

Graphical reference of many DIMVARS and some advanced information: DIMSTYLE Table

Source code file standards.py shows how to create your own DIMSTYLES.

The Script dimension_ordinate.py shows examples for angular dimensions.

Overriding Measurement Text?
See Linear Dimension Tutorial: Overriding Text Rotation

Measurement Text Formatting and Styling?
See Linear Dimension Tutorial: Measurement Text Formatting and Styling

Tolerances and Limits?
See Linear Dimension Tutorial: Tolerances and Limits

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/geo.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Setup Geo Location Reference
Load GPX Data
Export DXF Entities as GeoJSON
Custom Transformation Function
Polygon Validation by Shapely
Interface to GDAL/OGR
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for the Geo Add-on
Tutorial for the Geo Add-on?
This tutorial shows how to load a GPS track into a geo located DXF file and also the inverse operation, exporting geo located DXF entities as GeoJSON files.

Please read the section Intended Usage in the documentation of the ezdxf.addons.geo module first.

Warning

TO ALL BEGINNERS!

If you are just learning to work with geospatial data, using DXF files is not the way to go! DXF is not the first choice for storing data for spatial data analysts. If you run into problems I cannot help you as I am just learning myself.

The complete source code and test data for this tutorial are available in the github repository:

https://github.com/mozman/ezdxf/tree/master/docs/source/tutorials/src/geo

Setup Geo Location Reference?
The first step is setting up the geo location reference, which is not doable with ezdxf yet - this feature may come in the future - but for now you have to use a CAD application to do this. If the DXF file has no geo location reference the projected 2D coordinates are most likely far away from the WCS origin (0, 0), use the CAD command ZOOM EXTENDS to find the data.

Load GPX Data?
The GPX format stores GPS data in a XML format, use the ElementTree class to load the data:

def load_gpx_track(p: Path) -> Iterable[Tuple[float, float]]:
    """Load all track points from all track segments at once."""
    gpx = ET.parse(p)
    root = gpx.getroot()
    for track_point in root.findall(".//gpx:trkpt", GPX_NS):
        data = track_point.attrib
        # Elevation is not supported by the geo add-on.
        yield float(data["lon"]), float(data["lat"])
The loaded GPS data has a WSG84 EPSG:4326 projection as longitude and latitude in decimal degrees. The next step is to create a GeoProxy object from this data, the GeoProxy.parse() method accepts a __geo_interface__ mapping or a Python object with a __geo_interface__ attribute/property. In this case as simple LineString object for all GPS points is sufficient:

def add_gpx_track(msp, track_data, layer: str):
    geo_mapping = {
        "type": "LineString",
        "coordinates": track_data,
    }
    geo_track = geo.GeoProxy.parse(geo_mapping)
Transform the data from the polar representation EPSG:4326 into a 2D cartesian map representation EPSG:3395 called World Mercator , this is the only projection supported by the add-on, without the need to write a custom transformation function:

    geo_track.globe_to_map()
The data is now transformed into 2D cartesian coordinates in meters and most likely far away from origin (0, 0), the data stored in the GEODATA entity helps to transform the data into the DXF WCS in modelspace units, if the DXF file has no geo location reference you have to stick with the large coordinates:

    # Load geo data information from the DXF file:
    geo_data = msp.get_geodata()
    if geo_data:
        # Get the transformation matrix and epsg code:
        m, epsg = geo_data.get_crs_transformation()
    else:
        # Identity matrix for DXF files without a geo location reference:
        m = Matrix44()
        epsg = 3395
    # Check for compatible projection:
    if epsg == 3395:
        # Transform CRS coordinates into DXF WCS:
        geo_track.crs_to_wcs(m)
        # Create DXF entities (LWPOLYLINE)
        for entity in geo_track.to_dxf_entities(dxfattribs={"layer": layer}):
            # Add entity to the modelspace:
            msp.add_entity(entity)
    else:
        print(f"Incompatible CRS EPSG:{epsg}")
We are ready to save the final DXF file:

doc.saveas(str(out_path))
In BricsCAD the result looks like this, the underlying images were added by the BricsCAD command MAPCONNECT and such a feature is not planned for the add-on:

../_images/gpx_tracks.png
Export DXF Entities as GeoJSON?
This will only work with a proper geo location reference, the code shown accepts also WCS data from DXF files without a GEODATA object, but the result is just unusable - but in valid GeoJSON notation.

First get epsg code and the CRS transformation matrix:

    # Get the geo location information from the DXF file:
    geo_data = msp.get_geodata()
    if geo_data:
        # Get transformation matrix and epsg code:
        m, epsg = geo_data.get_crs_transformation()
    else:
        # Identity matrix for DXF files without geo reference data:
        m = Matrix44()
Query the DXF entities to export:

    for track in msp.query("LWPOLYLINE"):
        export_geojson(track, m)
Create a GeoProxy object from the DXF entity:

def export_geojson(entity, m):
    # Convert DXF entity into a GeoProxy object:
    geo_proxy = geo.proxy(entity)
Transform DXF WCS coordinates in modelspace units into the CRS coordinate system by the transformation matrix m:

    # Transform DXF WCS coordinates into CRS coordinates:
    geo_proxy.wcs_to_crs(m)
The next step assumes a EPSG:3395 projection, everything else needs a custom transformation function:

    # Transform 2D map projection EPSG:3395 into globe (polar)
    # representation EPSG:4326
    geo_proxy.map_to_globe()
Use the json module from the Python standard library to write the GeoJSON data, provided by the GeoProxy.__geo_interface__ property:

    # Export GeoJSON data:
    name = entity.dxf.layer + ".geojson"
    with open(TRACK_DATA / name, "wt", encoding="utf8") as fp:
        json.dump(geo_proxy.__geo_interface__, fp, indent=2)
The content of the GeoJSON file looks like this:

{
  "type": "LineString",
  "coordinates": [
    [
      15.430999,
      47.06503
    ],
    [
      15.431039,
      47.064797
    ],
    [
      15.431206,
      47.064582
    ],
    [
      15.431283,
      47.064342
    ],
    ...
}
Custom Transformation Function?
This sections shows how to use the GDAL package to write a custom transformation function. The example reimplements the builtin transformation from unprojected WGS84 coordinates to 2D map coordinates EPSG:3395 World Mercator :

from osgeo import osr
from ezdxf.math import Vec3

# GPS track in WGS84, load_gpx_track() code see above
gpx_points = list(load_gpx_track('track1.gpx'))

# Create source coordinate system:
src_datum = osr.SpatialReference()
src_datum.SetWellKnownGeoCS('WGS84')

# Create target coordinate system:
target_datum = osr.SpatialReference()
target_datum.SetWellKnownGeoCS('EPSG:3395')

# Create transformation object:
ct = osr.CoordinateTransform(src_datum, target_datum)

# Create GeoProxy() object:
geo_proxy = GeoProxy.parse({
    'type': 'LineString',
    'coordinates': gpx_points
})

# Apply a custom transformation function to all coordinates:
geo_proxy.apply(lambda v: Vec3(ct.TransformPoint(v.x, v.y)))
The same example with the pyproj package:

from pyproj import Transformer
from ezdxf.math import Vec3

# GPS track in WGS84, load_gpx_track() code see above
gpx_points = list(load_gpx_track('track1.gpx'))

# Create transformation object:
ct = Transformer.from_crs('EPSG:4326', 'EPSG:3395')

# Create GeoProxy() object:
geo_proxy = GeoProxy.parse({
    'type': 'LineString',
    'coordinates': gpx_points
})

# Apply a custom transformation function to all coordinates:
geo_proxy.apply(lambda v: Vec3(ct.transform(v.x, v.y)))
Polygon Validation by Shapely?
Ezdxf tries to avoid to create invalid polygons from HATCH entities like a hole in another hole, but not all problems are detected by ezdxf, especially overlapping polygons. For a reliable and robust result use the Shapely package to check for valid polygons:

import ezdxf
from ezdxf.addons import geo
from shapely.geometry import shape

# Load DXF document including HATCH entities.
doc = ezdxf.readfile('hatch.dxf')
msp = doc.modelspace()

# Test a single entity
# Get the first DXF hatch entity:
hatch_entity = msp.query('HATCH').first

# Create GeoProxy() object:
hatch_proxy = geo.proxy(hatch_entity)

# Shapely supports the __geo_interface__
shapely_polygon = shape(hatch_proxy)

if shapely_polygon.is_valid:
    ...
else:
    print(f'Invalid Polygon from {str(hatch_entity)}.')

# Remove invalid entities by a filter function
def validate(geo_proxy: geo.GeoProxy) -> bool:
    # Multi-entities are divided into single entities:
    # e.g. MultiPolygon is verified as multiple single Polygon entities.
    if geo_proxy.geotype == 'Polygon':
        return shape(geo_proxy).is_valid
    return True

# The gfilter() function let only pass compatible DXF entities
msp_proxy = geo.GeoProxy.from_dxf_entities(geo.gfilter(msp))

# remove all mappings for which validate() returns False
msp_proxy.filter(validate)
Interface to GDAL/OGR?
The GDAL/OGR package has no direct support for the __geo_interface__, but has builtin support for the GeoJSON format:

from osgeo import ogr
from ezdxf.addons import geo
from ezdxf.render import random_2d_path
import json

p = geo.GeoProxy({'type': 'LineString', 'coordinates': list(random_2d_path(20))})
# Create a GeoJSON string from the __geo_interface__ object by the json
# module and feed the result into ogr:
line_string = ogr.CreateGeometryFromJson(json.dumps(p.__geo_interface__))

# Parse the GeoJSON string from ogr by the json module and feed the result
# into a GeoProxy() object:
p2 = geo.GeoProxy.parse(json.loads(line_string.ExportToJson()))
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/custom_data.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Retrieving User Data
AutoLISP Resources
Header Section
Predefined User Variables
Custom Document Properties
Meta Data
XDATA
XDATA Helper Classes
Extension Dictionaries
XRecord
XRecord Helper Classes
AppData
Tutorial for External References
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Storing Custom Data in DXF Files
Storing Custom Data in DXF Files?
This tutorial describes how to store custom data in DXF files using standard DXF features.

Saving data in comments is not covered in this section, because comments are not a reliable way to store information in DXF files and ezdxf does not support adding comments to DXF files. Comments are also ignored by ezdxf and many other DXF libraries when loading DXF files, but there is a ezdxf.comments module to load comments from DXF files.

The DXF data format is a very versatile and flexible data format and supports various ways to store custom data. This starts by setting special header variables, storing XData, AppData and extension dictionaries in DXF entities and objects, storing XRecords in the OBJECTS section and ends by using proxy entities or even extending the DXF format by user defined entities and objects.

This is the common prolog for all Python code examples shown in this tutorial:

import ezdxf

doc = ezdxf.new()
msp = doc.modelspace()
Retrieving User Data?
Retrieving the custom data is a simple task by ezdxf, but often not possible in CAD applications without using the scripting features (AutoLISP) or even the SDK.

AutoLISP Resources?
Autodesk Developer Documentation

AfraLISP

Lee Mac Programming

Warning

I have no experience with AutoLISP so far and I created this scripts for AutoLISP while writing this tutorial. There may be better ways to accomplish these tasks, and feedback on this is very welcome. Everything is tested with BricsCAD and should also work with the full version of AutoCAD.

Header Section?
The HEADER section has tow ways to store custom data.

Predefined User Variables?
There are ten predefined user variables, five 16-bit integer variables called $USERI1 up to $USERI5 and five floating point variables (reals) called $USERR1 up to $USERR5. This is very limited and the data maybe will be overwritten by the next application which opens and saves the DXF file. Advantage of this methods is, it works for all supported DXF versions starting at R12.

Settings the data:

doc.header["$USERI1"] = 4711
doc.header["$USERR1"] = 3.141592
Getting the data by ezdxf:

i1 = doc.header["$USERI1"]
r1 = doc.header["$USERR1"]
Getting the data in BricsCAD at the command line:

: USERI1
New current value for USERI1 (-32768 to 32767) <4711>:
Getting the data by AutoLISP:

: (getvar 'USERI1)
4711
Setting the value by AutoLISP:

: (setvar 'USERI1 1234)
1234
Custom Document Properties?
This method defines custom document properties, but requires at least DXF R2004. The custom document properties are stored in a CustomVars instance in the custom_vars attribute of the HeaderSection object and supports only string values.

Settings the data:

doc.header.custom_vars.append("MyFirstVar", "First Value")
Getting the data by ezdxf:

my_first_var = doc.header.custom_vars.get("MyFirstVar", "Default Value")
The document property MyFirstVar is available in BricsCAD as FIELD variable:

../_images/custom_header_property.png
AutoLISP script for getting the custom document properties:

(defun C:CUSTOMDOCPROPS (/ Info Num Index Custom)
  (vl-load-com)
  (setq acadObject (vlax-get-acad-object))
  (setq acadDocument (vla-get-ActiveDocument acadObject))

  ;;Get the SummaryInfo
  (setq Info (vlax-get-Property acadDocument 'SummaryInfo))
  (setq Num (vla-NumCustomInfo Info))
  (setq Index 0)
  (repeat Num
    (vla-getCustomByIndex Info Index 'ID 'Value)
    (setq Custom (cons (cons ID Value) Custom))
    (setq Index (1+ Index))
  )  ;repeat

  (if Custom (reverse Custom))
)
Running the script in BricsCAD:

: (load "customdocprops.lsp")
C:CUSTOMDOCPROPS
: CUSTOMDOCPROPS
(("MyFirstVar" . "First Value"))
Meta Data?
Starting with version v0.16.4 ezdxf stores some meta data in the DXF file and the AppID EZDXF will be created. Two entries will be added to the MetaData instance, the CREATED_BY_EZDXF for DXF documents created by ezdxf and the entry WRITTEN_BY_EZDXF if the DXF document will be saved by ezdxf. The marker string looks like this "0.17b0 @ 2021-09-18T05:14:37.921826+00:00" and contains the ezdxf version and an UTC timestamp in ISO format.

You can add your own data to the MetaData instance as a string with a maximum of 254 characters and choose a good name which may never be used by ezdxf in the future.

metadata = doc.ezdxf_metadata()
metadata["MY_UNIQUE_KEY"] = "my additional meta data"

print(metadata.get("CREATED_BY_EZDXF"))
print(metadata.get("MY_UNIQUE_KEY"))
The data is stored as XDATA in then BLOCK entity of the model space for DXF R12 and for DXF R2000 and later as a DXF Dictionary in the root dictionary by the key EZDXF_META. See following chapters for accessing such data by AutoLISP.

XDATA?
Extended Data (XDATA) is a way to attach arbitrary data to DXF entities. Each application needs a unique AppID registered in the AppID table to add XDATA to an entity. The AppID ACAD is reserved and by using ezdxf the AppID EZDXF is also registered automatically. The total size of XDATA for a single DXF entity is limited to 16kB for AutoCAD. XDATA is supported by all DXF versions and is accessible by AutoLISP.

The valid group codes for extended data are limited to the following values, see also the internals of Extended Data:

Group Code

Description

1000

Strings up to 255 bytes long

1001

(fixed) Registered application name up to 31 bytes long

1002

(fixed) An extended data control string '{' or '}'

1004

Binary data

1005

Database Handle of entities in the drawing database

1010

3D point, in the order X, Y, Z that will not be modified at any transformation of the entity

1011

A WCS point that is moved, scaled, rotated and mirrored along with the entity

1012

A WCS displacement that is scaled, rotated and mirrored along with the entity, but not moved

1013

A WCS direction that is rotated and mirrored along with the entity but not moved and scaled.

1040

A real value

1041

Distance, a real value that is scaled along with the entity

1042

Scale Factor, a real value that is scaled along with the entity

1070

A 16-bit integer (signed or unsigned)

1071

A 32-bit signed (long) integer

Group codes are not unique in the XDATA section and can be repeated, therefore tag order matters.

# register your appid
APPID = "YOUR_UNIQUE_ID"
doc.appids.add(APPID)

# create a DXF entity
line = msp.add_line((0, 0), (1, 0))

# setting the data
line.set_xdata(APPID, [
    # basic types
    (1000, "custom text"),
    (1040, 3.141592),
    (1070, 4711),  # 16bit
    (1071, 1_048_576),  # 32bit
    # points and vectors
    (1010, (10, 20, 30)),
    (1011, (11, 21, 31)),
    (1012, (12, 22, 32)),
    (1013, (13, 23, 33)),
    # scaled distances and factors
    (1041, 10),
    (1042, 10),
])

# getting the data
if line.has_xdata(APPID):
    tags = line.get_xdata(APPID)
    print(f"{str(line)} has {len(tags)} tags of XDATA for AppID {APPID!r}")
    for tag in tags:
        print(tag)
AutoLISP script for getting XDATA for AppID YOUR_UNIQUE_ID:

(defun C:SHOWXDATA (/ entity_list xdata_list)
    (setq entity_list (entget (car (entsel)) '("YOUR_UNIQUE_ID")))
    (setq xdata_list (assoc -3 entity_list))
    (car (cdr xdata_list))
)
Script output:

: SHOWXDATA
Select entity: ("YOUR_UNIQUE_ID" (1000 . "custom text") (1040 . 3.141592) ...
See also

AfraLISP XDATA tutorial

Extended Data (XDATA) Reference

XDATA Helper Classes?
The XDataUserList and XDataUserDict are helper classes to manage XDATA content in a simple way.

Both classes store the Python types int, float and str and the ezdxf type Vec3. As the names suggests has the XDataUserList a list-like interface and the XDataUserDict a dict-like interface. This classes can not contain additional container types, but multiple lists and/or dicts can be stored in the same XDATA section for the same AppID.

These helper classes uses a fixed group code for each data type:

1001

strings (max. 255 chars)

1040

floats

1071

32-bit ints

1010

Vec3

Additional required imports for these examples:

from ezdxf.math import Vec3
from ezdxf.entities.xdata import XDataUserDict, XDataUserList
Example for XDataUserDict:

Each XDataUserDict has a unique name, the default name is DefaultDict and the default AppID is EZDXF. If you use your own AppID, don t forget to create the requited AppID table entry like doc.appids.new("MyAppID"), otherwise AutoCAD will not open the DXF file.

doc = ezdxf.new()
msp = doc.modelspace()
line = msp.add_line((0, 0), (1, 0))

with XDataUserDict.entity(line) as user_dict:
    user_dict["CreatedBy"] = "mozman"
    user_dict["Float"] = 3.1415
    user_dict["Int"] = 4711
    user_dict["Point"] = Vec3(1, 2, 3)
If you modify the content of without using the context manager entity(), you have to call commit() by yourself, to transfer the modified data back into the XDATA section.

Getting the data back from an entity:

with XDataUserDict.entity(line) as user_dict:
    print(user_dict)
    # acts like any other dict()
    storage = dict(user_dict)
Example for XDataUserList:

This example stores the data in a XDataUserList named AppendedPoints , the default name is DefaultList and the default AppID is EZDXF.

with XDataUserList.entity(line, name="AppendedPoints") as user_list:
    user_list.append(Vec3(1, 0, 0))
    user_list.append(Vec3(0, 1, 0))
    user_list.append(Vec3(0, 0, 1))
Now the content of both classes are stored in the same XDATA section for AppID EZDXF. The XDataUserDict is stored by the name DefaultDict and the XDataUserList is stored by the name AppendedPoints .

Getting the data back from an entity:

with XDataUserList.entity(line, name="AppendedPoints") as user_list:
    print(user_list)
    storage = list(user_list)

print(f"Copy of XDataUserList: {storage}")
See also

XDataUserList class

XDataUserDict class

Extension Dictionaries?
Extension dictionaries are another way to attach custom data to any DXF entity. This method requires DXF R13/14 or later. I will use the short term XDICT for extension dictionaries in this tutorial.

The Extension Dictionary is a regular DXF Dictionary which can store (key, value) pairs where the key is a string and the value is a DXF object from the OBJECTS section. The usual objects to store custom data are DictionaryVar to store simple strings and XRecord to store complex data.

Unlike XDATA, custom data attached by extension dictionary will not be transformed along with the DXF entity!

This example shows how to manage the XDICT and to store simple strings as DictionaryVar objects in the XDICT, to store more complex data go to the next section XRecord.

Get or create the XDICT for an entity:

# create a DXF entity
line = msp.add_line((0, 0), (1, 0))

if line.has_extension_dict:
    # get the extension dictionary
    xdict = line.get_extension_dict()
else:
    # create a new extension dictionary
    xdict = line.new_extension_dict()
2. Add strings as DictionaryVar objects to the XDICT. No AppIDs required, but existing keys will be overridden, so be careful by choosing your keys:

xdict.add_dictionary_var("DATA1", "Your custom data string 1")
xdict.add_dictionary_var("DATA2", "Your custom data string 2")
3. Retrieve the strings from the XDICT as DictionaryVar objects:

print(f"DATA1 is '{xdict['DATA1'].value}'")
print(f"DATA2 is '{xdict['DATA2'].value}'")
The AutoLISP access to DICTIONARIES is possible, but it gets complex and I m only referring to the AfraLISP Dictionaries and XRecords tutorial.

See also

AfraLISP Dictionaries and XRecords Tutorial

Extension Dictionary Reference

DXF Dictionary Reference

DictionaryVar Reference

XRecord?
The XRecord object can store arbitrary data like the XDATA section, but is not limited by size and can use all group codes in the range from 1 to 369 for DXF Tags. The XRecord can be referenced by any DXF Dictionary, other XRecord objects (tricky ownership!), the XDATA section (store handle by group code 1005) or any other DXF object by adding the XRecord object to the Extension Dictionary of the DXF entity.

It is recommend to follow the DXF reference to assign appropriate group codes to DXF Tags. My recommendation is shown in the table below, but all group codes from 1 to 369 are valid. I advice against using the group codes 100 and 102 (structure tags) to avoid confusing generic tag loaders. Unfortunately, Autodesk doesn t like general rules and uses DXF format exceptions everywhere.

1

strings (max. 2049 chars)

2

structure tags as strings like "{" and "}"

10

points and vectors

40

floats

90

integers

330

handles

Group codes are not unique in XRecord and can be repeated, therefore tag order matters.

This example shows how to attach a XRecord object to a LINE entity by Extension Dictionary:

line = msp.add_line((0, 0), (1, 0))
line2 = msp.add_line((0, 2), (1, 2))

if line.has_extension_dict:
    xdict = line.get_extension_dict()
else:
    xdict = line.new_extension_dict()

xrecord = xdict.add_xrecord("DATA1")
xrecord.reset([
    (1, "text1"),  # string
    (40, 3.141592),  # float
    (90, 256),  # 32-bit int
    (10, (1, 2, 0)),  # points and vectors
    (330, line2.dxf.handle)  # handles
])

print(xrecord.tags)
Script output:

[DXFTag(1, 'text1'),
 DXFTag(40, 3.141592),
 DXFTag(90, 256),
 DXFVertex(10, (1.0, 2.0, 0.0)),
 DXFTag(330, '30')]
Unlike XDATA, custom data attached by extension dictionary will not be transformed along with the DXF entity! To react to entity modifications by a CAD applications it is possible to write event handlers by AutoLISP, see the AfraLISP Reactors Tutorial for more information. This is very advanced stuff!

See also

AfraLISP Dictionaries and XRecords Tutorial

AfraLISP Reactors Tutorial

XRecord Reference

helper functions: ezdxf.lldxf.types.dxftag() and ezdxf.lldxf.types.tuples_to_tags()

XRecord Helper Classes?
The UserRecord and BinaryRecord are helper classes to manage XRECORD content in a simple way. The UserRecord manages the data as plain Python types: dict, list, int, float, str and the ezdxf types Vec2 and Vec3. The top level type for the UserRecord.data attribute has to be a list. The BinaryRecord stores arbitrary binary data as BLOB. These helper classes uses fixed group codes to manage the data in XRECORD, you have no choice to change them.

Additional required imports for these examples:

from pprint import pprint
import ezdxf
from ezdxf.math import Vec3
from ezdxf.urecord import UserRecord, BinaryRecord
from ezdxf.entities import XRecord
import zlib
Example 1: Store entity specific data in the Extension Dictionary:

line = msp.add_line((0, 0), (1, 0))
xdict = line.new_extension_dict()
xrecord = xdict.add_xrecord("MyData")

with UserRecord(xrecord) as user_record:
    user_record.data = [  # top level has to be a list!
        "MyString",
        4711,
        3.1415,
        Vec3(1, 2, 3),
        {
            "MyIntList": [1, 2, 3],
            "MyFloatList": [4.5, 5.6, 7.8],
        },
    ]
Example 1: Get entity specific data back from the Extension Dictionary:

if line.has_extension_dict:
    xdict = line.get_extension_dict()
    xrecord = xdict.get("MyData")
    if isinstance(xrecord, XRecord):
        user_record = UserRecord(xrecord)
        pprint(user_record.data)
If you modify the content of UserRecord.data without using the context manager, you have to call commit() by yourself, to store the modified data back into the XRECORD.

Example 2: Store arbitrary data in DICTIONARY objects. The XRECORD is stored in the named DICTIONARY, called rootdict in ezdxf. This DICTIONARY is the root entity for the tree-like data structure stored in the OBJECTS section, see also the documentation of the ezdxf.sections.objects module.

# Get the existing DICTIONARY object or create a new DICTIONARY object:
my_dict = doc.objects.rootdict.get_required_dict("MyDict")

# Create a new XRECORD object, the DICTIONARY object is the owner of this
# new XRECORD:
xrecord = my_dict.add_xrecord("MyData")

# This example creates the user record without the context manager.
user_record = UserRecord(xrecord)

# Store user data:
user_record.data = [
    "Just another user record",
    4711,
    3.1415,
]
# Store user data in associated XRECORD:
user_record.commit()
Example 2: Get user data back from the DICTIONARY object

my_dict = doc.rootdict.get_required_dict("MyDict")
entity = my_dict["MyData"]
if isinstance(entity, XRecord):
    user_record = UserRecord(entity)
    pprint(user_record.data)
Example 3: Store arbitrary binary data

my_dict = doc.rootdict.get_required_dict("MyDict")
xrecord = my_dict.add_xrecord("MyBinaryData")
with BinaryRecord(xrecord) as binary_record:
    # The content is stored as hex strings (e.g. ABBAFEFE...) in one or more
    # group code 310 tags.
    # A preceding group code 160 tag stores the data size in bytes.
    data = b"Store any binary data, even line breaks\r\n" * 20
    # compress data if required
    binary_record.data = zlib.compress(data, level=9)
Example 3: Get binary data back from the DICTIONARY object

entity = my_dict["MyBinaryData"]
if isinstance(entity, XRecord):
    binary_record = BinaryRecord(entity)
    print("\ncompressed data:")
    pprint(binary_record.data)

    print("\nuncompressed data:")
    pprint(zlib.decompress(binary_record.data))
Hint

Don t be fooled, the ability to save any binary data such as images, office documents, etc. in the DXF file doesn t impress AutoCAD, it simply ignores this data, this data only has a meaning for your application!

See also

urecord module

UserRecord class

BinaryRecord class

AppData?
Application-Defined Data (AppData) was introduced in DXF R13/14 and is used by AutoCAD internally to store the handle to the Extension Dictionary and the Reactors in DXF entities. Ezdxf supports these kind of data storage for any AppID and the data is preserved by AutoCAD and BricsCAD, but I haven t found a way to access this data by AutoLISP or even the SDK. So I don t recommend this feature to store application defined data, because Extended Data (XDATA) and the Extension Dictionary are well documented and safe ways to attach custom data to entities.

# register your appid
APPID = "YOUR_UNIQUE_ID"
doc.appids.add(APPID)

# create a DXF entity
line = msp.add_line((0, 0), (1, 0))

# setting the data
line.set_app_data(APPID, [(300, "custom text"), (370, 4711), (460, 3.141592)])

# getting the data
if line.has_app_data(APPID):
    tags = line.get_app_data(APPID)
    print(f"{str(line)} has {len(tags)} tags of AppData for AppID {APPID!r}")
    for tag in tags:
        print(tag)
Printed output:

LINE(#30) has 3 tags of AppData for AppID 'YOUR_UNIQUE_ID'
(300, 'custom text')
(370, 4711)
(460, 3.141592)
Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/xref_module.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Introduction
Supported Entities
Environment Setup
Attach a DXF File
Attach a DWG File
Detach an XREF
Embed an XREF
Load Modelspace
Load Paperspace
Write Block
Conflict Policies
ConflictPolicy.KEEP
ConflictPolicy.XREF_PREFIX
ConflictPolicy.NUM_PREFIX
Load Table Resources
Tutorial for Image Export
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for External References
Tutorial for External References?
Introduction

Supported Entities

Environment Setup

Attach a DXF File

Attach a DWG File

Detach an XREF

Embed an XREF

Load Modelspace

Load Paperspace

Write Block

Conflict Policies

ConflictPolicy.KEEP

ConflictPolicy.XREF_PREFIX

ConflictPolicy.NUM_PREFIX

Load Table Resources

Introduction?
This tutorial uses the ezdxf.xref module to work with external references (XREF).

Attached XREFs are links to the modelspace of a specified drawing file. Changes made to the referenced drawing are automatically reflected in the current drawing when it s opened or if the XREF is reloaded.

Important

AutoCAD can only display DWG files as attached XREFs. Any DXF file attached as an XREF to a DXF document must be converted to DWG in order to be viewed in AutoCAD. Fortunately, other CAD applications are more cooperative, BricsCAD has no problem displaying DXF files as XREFs.

The drawing add-on included in ezdxf does not display external references at all!

There are some example files included in the examples/xref folder of the repository:

attach_dxf_dwg_xref.py

detach_block_as_xref.py

embed_dxf_dwg_xref.py

load_table_resources.py

Supported Entities?
All operations which move entities between layouts and XREFs copy these entities, therefore only entities which are copyable can be transferred. The following entities are not copyable:

All entities which are not documented by the DXF reference.

ACAD_TABLE

ACAD_PROXY_ENTITY

OLE2FRAME

ACIS based entities: BODY, 3DSOLID, REGION,

Custom entities from applications on top of AutoCAD like Map 3D, Civil 3D or Architecture. The vertical integration stack is not documented by the DXF reference.

Unsupported entities are ignored and do not raise exceptions.

Environment Setup?
Required imports to follow this tutorial:

import ezdxf
from ezdxf.addons import odafc
from ezdxf.document import Drawing
from ezdxf import xref, units, colors
from ezdxf.render import forms

DXFVERSION = "R2013"
Function to create a simple DXF file as XREF, the insertion point of the XREF is set to (5, 5):

def make_dxf_xref_document(name: str) -> Drawing:
    ref_doc = ezdxf.new(DXFVERSION, units=units.M)
    ref_doc.layers.add("GEAR", color=colors.YELLOW)
    msp = ref_doc.modelspace()
    gear = forms.gear(
        16, top_width=0.25, bottom_width=0.75, height=0.5, outside_radius=2.5
    )
    msp.add_lwpolyline(
        forms.translate(gear, (5, 5)), close=True, dxfattribs={"layer": "GEAR"}
    )
    ref_doc.header["$INSBASE"] = (5, 5, 0)
    ref_doc.saveas(name)
    return ref_doc
Create the DXF file:

make_dxf_xref_document("xref.dxf")
The XREF looks like this:

../_images/xref_doc.png
Attach a DXF File?
Create a host document to which the XREF will be attached:

host_doc = ezdxf.new(DXFVERSION, units=units.M)
Attach the XREF by the ezdxf.xref.attach() function and save the host DXF file:

xref.attach(host_doc, block_name="dxf_xref", insert=(0, 0), filename="attached_xref.dxf")
host_doc.set_modelspace_vport(height=10, center=(0, 0))
host_doc.saveas("attach_host_dxf.dxf")
The attach() function is meant to simply attach an XREF once without any overhead, therefore the attach() function creates the required block definition automatically and raises an XrefDefinitionError exception if the block definition already exist. To attach additional XREF references use the method add_blockref():

msp.add_blockref("dxf_xref", insert=another_location)
The attached DXF file in BricsCAD:

../_images/xref_attached_dxf.png
Important

AutoCAD can not display DXF files as attached XREFs.

Attach a DWG File?
Export the DXF file as DWG by the odafc add-on:

# It's not required to save the DXF file!
doc = make_dxf_xref_document("attached_xref.dxf")
try:
    odafc.export_dwg(doc, "attached_xref.dwg", replace=True)
except odafc.ODAFCError as e:
    print(str(e))
Attach the DWG file by the ezdxf.xref.attach() function and save the host DXF file:

host_doc = ezdxf.new(DXFVERSION, units=units.M)
xref.attach(host_doc, block_name="dwg_xref", filename="attached_xref.dwg", insert=(0, 0))
host_doc.set_modelspace_vport(height=10, center=(0, 0))
host_doc.saveas("attached_dwg.dxf")
Attached DWG file in Autodesk DWG TrueView 2023:

../_images/xref_attached_dwg.png
Detach an XREF?
The detach() function writes the content of a block definition into the modelspace of a new DXF document and convert the block to an external reference (XREF). The new DXF document has to be written/exported by the caller. The function does not create any block references. These references should already exist and do not need to be changed since references to blocks and XREFs are the same.

    host_doc = ezdxf.new()
    make_block(host_doc, "GEAR")
    block_layout = host_doc.blocks.get("GEAR")
    detached_block_doc = xref.detach(block_layout, xref_filename="detached_gear.dxf")
    detached_block_doc.saveas("detached_gear.dxf")
    host_doc.set_modelspace_vport(height=10, center=(0, 0))
    host_doc.saveas("detach_host_dxf_xref.dxf")
Important

Save the host document after detaching the block! Detaching a block definition modifies the host document.

The detach() function returns a Drawing instance, so it s possible to convert the DXF document to DWG by the odafc add-on if necessary (e.g. for Autodesk products). It s important that the argument xref_filename match the filename of the exported DWG file:

    host_doc = ezdxf.new()
    make_block(host_doc, "GEAR")
    block_layout = host_doc.blocks.get("GEAR")
    detached_block_doc = xref.detach(block_layout, xref_filename="detached_gear.dwg")
    try:
        odafc.export_dwg(detached_block_doc, "detached_gear.dwg", replace=True)
    except odafc.ODAFCError as e:
        print(str(e))
    host_doc.set_modelspace_vport(height=10, center=(0, 0))
    host_doc.saveas("detach_host_dwg_xref.dxf")
It s recommended to clean up the entity database of the host document afterwards:

host_doc.entitydb.purge()
For understanding, this is the make_block() function:

def make_block(doc: Drawing, name: str) -> None:
    blk = doc.blocks.new(name, base_point=(5, 5, 0))
    doc.layers.add("GEAR", color=colors.YELLOW)
    gear = forms.gear(
        16, top_width=0.25, bottom_width=0.75, height=0.5, outside_radius=2.5
    )
    blk.add_lwpolyline(
        forms.translate(gear, (5, 5)), close=True, dxfattribs={"layer": "GEAR"}
    )
    doc.modelspace().add_blockref(name, (0, 0))
Embed an XREF?
The embed() function loads the content of the XREF into the block definition, this is the reverse operation of detaching an XREF.

For loading the content of DWG files is a loading function required, which loads the DWG file as Drawing document. The odafc add-on module provides such a function: readfile().

This example embeds the XREF attached_xref.dwg of the first example as content of the block definition GEAR , the attach_host_dwg.dxf file is the host DXF document:

import ezdxf
from ezdxf.addons import odafc

doc = ezdxf.readfile("attach_host_dwg.dxf")
gear_xref = doc.blocks.get("GEAR")

try:
    xref.embed(gear_xref, load_fn=odafc.readfile)
except FileNotFoundError as e:
    print(str(e))
The default loading function for DXF files is the ezdxf.readfile() function and doesn t have to be specified. For the loading function from the recover module use a lambda function:

import ezdxf
from ezdxf import recover

doc = ezdxf.readfile("attach_host_dxf.dxf")
gear_xref = doc.blocks.get("GEAR")

try:
    xref.embed(gear_xref, load_fn=lambda f: recover.readfile(f)[0])
except FileNotFoundError as e:
    print(str(e))
Load Modelspace?
The ezdxf.xref.load_modelspace() function loads the content of the modelspace of the source document into a layout of the target document, the modelspace of the target document is the default target layout.

Hint

Use this function to combine multiple existing DXF files. If the goal is just to add new entities to an existing document, rather load the source document as a template by ezdxf.readfile(), add your content and save the document as a new DXF file with the saveas() method.

Merge multiple DXF files:

import ezdxf
from ezdxf import colors, transform, xref
from ezdxf.math import Matrix44
from ezdxf.render import forms


def make_gear(name: str) -> None:
    doc = ezdxf.new()
    doc.layers.add("GEAR", color=colors.YELLOW)
    msp = doc.modelspace()
    gear = forms.gear(
        16, top_width=0.25, bottom_width=0.75, height=0.5, outside_radius=2.5
    )
    msp.add_lwpolyline(gear, close=True, dxfattribs={"layer": "GEAR"})
    doc.saveas(name)


make_gear("gear.dxf")
merged_doc = ezdxf.new()
for index in range(3):
    sdoc = ezdxf.readfile("gear.dxf")  # this could be different DXF files
    transform.inplace(sdoc.modelspace(), Matrix44.translate(index * 10, 0, 0))
    xref.load_modelspace(sdoc, merged_doc)
merged_doc.saveas("merged.dxf")
../_images/xref_merged.png
Load Paperspace?
The function ezdxf.xref.load_paperspace() loads a paperspace layout as a new paperspace layout into the target document. To be clear this function loads only the content of the paperspace layout, the content of the modelspace isn t loaded, therefore the loaded VIEWPORT entities show the content of the target modelspace.

Write Block?
The function ezdxf.xref.write_block() writes the given entities into the modelspace of a new DXF document, this document can be, but doesn t have to be used as an external referenced block.

Conflict Policies?
Resources are definitions of layers, linetypes, text-, dimension-, mline- and mleader styles, materials and blocks.

A resource conflict occurs when the source and target documents contain elements such as layers, linetypes, text styles and so on that share the same name.

Many of the functions shown above support an argument to define the ezdxf.xref.ConflictPolicy, that gives you the choice how to handle resource name conflicts.

ConflictPolicy.KEEP?
Keeps the existing resource name of the target document and ignore the resource from the source document. The loaded entities from the source document use the resources defined in the target document and may alter their visual appearance, when the resources are different.

ConflictPolicy.XREF_PREFIX?
This policy handles the resource import like CAD applications by always renaming the loaded resources to <xref>$0$<name>, where xref is the name of source document, the $0$ part is a number to create a unique resource name and <name> is the name of the resource itself.

Important

This policy ALWAYS renames the resource, even if the loaded resource doesn t have a conflict in the target document.

ConflictPolicy.NUM_PREFIX?
This policy renames the loaded resources to $0$<name> only if the resource <name> already exists. The $0$ prefix is a number to create a unique resource name and <name> is the name of the resource itself.

Important

This policy renames the resource ONLY when the loaded resource has a conflict in the target document.

Load Table Resources?
Resources are definitions of layers, linetypes, text-, dimension-, mline- and mleader styles, materials and blocks.

The Loader class is the low level tool to build a loading operation from simple loading commands. Study the source code of the xref module, most of loading commands used above are build upon the Loader class. This example shows how to import layer, linetype, text- and dimension style definitions:

import ezdxf
from ezdxf import xref

sdoc = ezdxf.new(setup=True)
tdoc = ezdxf.new()

# The default conflict policy is ConflictPolicy.KEEP
loader = xref.Loader(sdoc, tdoc)

# Load all layers:
loader.load_layers([layer.dxf.name for layer in sdoc.layers])

# Load specific linetypes:
loader.load_linetypes(["CENTER", "DASHED", "DASHDOT"])

# Load specific text style:
loader.load_text_styles(["OpenSans", "LiberationMono"])

# Load all DIMENSION styles, this command loads also the dependent text styles:
loader.load_dim_styles([dimstyle.dxf.name for dimstyle in sdoc.dimstyles])

# execute all loading commands:
loader.execute()
tdoc.saveas("target.dxf")
Note

Loading a layer does not load the entities which do reference this layer, a layer is not an entity container, it s just an DXF attribute, see also Basic Concepts: Layers.

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/image_export.html =====
ezdxf
Search docs
Introduction
Setup & Dependencies
Usage for Beginners
Basic Concepts
Tasks
External References (XREF)
Add-ons
Reference
Launcher
Tutorials
Tutorial for Getting Data from DXF Files
Tutorial for Creating DXF Drawings
Tutorial for Common Graphical Attributes
Tutorial for Layers
Tutorial for Creating Linetype Pattern
Tutorial for Creating Complex Linetype Pattern
Tutorial for Simple DXF Entities
Tutorial for Entity Selection
Tutorial for Blocks
Tutorial for LWPolyline
Tutorial for Text
Tutorial for MText and MTextEditor
Tutorial for Spline
Tutorial for Polyface
Tutorial for Mesh
Tutorial for Hatch
Tutorial for Hatch Pattern Definition
Tutorial for Image and ImageDef
Tutorial for Underlay and UnderlayDefinition
Tutorial for MultiLeader
Tutorial for Viewports in Paperspace
Tutorial for OCS/UCS Usage
Tutorial for UCS Based Transformations
Tutorial for Linear Dimensions
Tutorial for Radius Dimensions
Tutorial for Diameter Dimensions
Tutorial for Angular Dimensions
Tutorial for Arc Dimensions
Tutorial for Ordinate Dimensions
Tutorial for the Geo Add-on
Storing Custom Data in DXF Files
Tutorial for External References
Tutorial for Image Export
Introduction
Common Basics
Frontend Configuration
Page Layout
Autodetect Page Size
Scaling Content
Limit Page Size
SVG Export
PDF Export
PNG Export
PLT/HPGL2 Export
DXF Export
Recorder Backend
Tutorial for Finding Chains and Loops
Howto
FAQ
Glossary
Knowledge Graph
ezdxf
Tutorials
Tutorial for Image Export
Tutorial for Image Export?
Introduction

Common Basics

Frontend Configuration

Page Layout

Autodetect Page Size

Scaling Content

Limit Page Size

SVG Export

PDF Export

PNG Export

PLT/HPGL2 Export

DXF Export

Recorder Backend

Introduction?
This tutorial shows how to export DXF content of the modelspace or a paperspace as images by the drawing add-on.

The tutorial covers the new added backends in ezdxf version 1.1:

ezdxf.addons.drawing.svg.SVGBackend class for SVG export

ezdxf.addons.drawing.pymupdf.PyMuPdfBackend class for PDF and PNG export

ezdxf.addons.drawing.hpgl2.PlotterBackend class for PLT/HPGL2 export

ezdxf.addons.drawing.dxf.DXFBackend class for flattened DXF export

The tutorial does not cover the MatplotlibBackend and PyQtBackend, for information about these backends see:

Howtos for the Drawing Add-on

FAQs at github: https://github.com/mozman/ezdxf/discussions/550

Common Basics?
The rendering process is divided into multiple steps. The frontend resolves the DXF properties and breaks down complex DXF entities into simple drawing primitives which are send to the backend that renders the output format.

import ezdxf
from ezdxf.addons.drawing import Frontend, RenderContext, svg, layout


def example_doc():
    doc = ezdxf.new()
    msp = doc.modelspace()
    x0, y0, x1, y1 = 0, 0, 10, 10
    start = (x0, y0)
    end = (x0 + 1, y0)
    for color in range(1, 6):
        msp.add_lwpolyline(
            [start, (x0, y1), (x1, y1), (x1, y0), end], dxfattribs={"color": color}
        )
        x0 += 1
        x1 -= 1
        y0 += 1
        y1 -= 1
        start = end
        end = (x0 + 1, y0)
    return doc


def export(doc):
    msp = doc.modelspace()
    # 1. create the render context
    context = RenderContext(doc)
    # 2. create the backend
    backend = svg.SVGBackend()
    # 3. create the frontend
    frontend = Frontend(context, backend)
    # 4. draw the modelspace
    frontend.draw_layout(msp)
    # 5. create an A4 page layout, not required for all backends
    page = layout.Page(210, 297, layout.Units.mm, margins=layout.Margins.all(20))
    # 6. get the SVG rendering as string - this step is backend dependent
    svg_string = backend.get_string(page)
    with open("output.svg", "wt", encoding="utf8") as fp:
        fp.write(svg_string)


if __name__ == "__main__":
    export(example_doc())
The exported SVG shows a spiral centered on an A4 page with a margin of 20mm, notice the background has a dark color like the usual background of the modelspace:

../_images/image_export_01.png
Frontend Configuration?
The Configuration object configures the rendering process. This example changes the background color from dark grey to white and renders all lines black.

Add the config module to imports:

from ezdxf.addons.drawing import Frontend, RenderContext, svg, layout, config
Create a new configuration and override the background and color policy between the 2nd and the 3rd step:

    # 2. create the backend
    backend = svg.SVGBackend()
    # create a new configuration for a white background and and a black foreground color
    cfg = config.Configuration(
        background_policy=config.BackgroundPolicy.WHITE,
        color_policy=config.ColorPolicy.BLACK,
    )
    # 3. create the frontend
    frontend = Frontend(context, backend, config=cfg)
The new exported SVG has a white background and all lines are black:

../_images/image_export_02.png
There are many configuration options:

LineweightPolicy - relative, absolute or relative fixed lineweight

LinePolicy - solid or accurate linetypes

HatchPolicy - normal, ignore, only outlines or always solid fill

ColorPolicy - color, black, white, monochrome,

BackgroundPolicy - default, black, white, off (transparent) and custom

TextPolicy - filling, outline, ignore,

ProxyGraphicPolicy - ignore, show, prefer

lineweight scaling factor

minimal lineweight

max_flattening_distance for curve approximation

and more

All configuration options are documented here: Configuration.

Page Layout?
The Page object defines the output page for some backends (SVG, PDF, PNG, PLT).

A page is defined by width and height in a given length unit. The supported length units are millimeters (mm), inch (in), point (1 pt is 1/72 in) and pixels (1 px is 1/96 in).

It s possible to autodetect the page size from the content or fit the content onto the page. In both cases the margin values are used to create space between the content and the page borders. The content is centered in the remaining space without margins.

Important

None of the backends crop the content automatically, the margin values are just calculation values!

Autodetect Page Size?
The required page size is auto-detected by setting the width and/or height to 0. By default the scaling factor is 1, so 1 drawing unit is 1 page unit. The content is fit to page by default and the outcome is shown in the previous examples.

This example shows the output when the scale should be 1:1, 1 drawing unit is 1 page unit (mm):

    # auto-detect page size and 2mm margins on all sides
    page = layout.Page(0, 0, layout.Units.mm, margins=layout.Margins.all(2))
    # scale content by 1, do not fit content to page
    svg_string = backend.get_string(
        page, settings=layout.Settings(scale=1, fit_page=False)
    )
The page has a size of 14x14mm, a content size of 10x10mm and 2mm margins on all sides.

../_images/image_export_03.png
Scaling Content?
Scaling the content by factor 10 means, 10 page units represent 1 drawing unit, which is a scale of 10:1 and only uniform scaling is supported.

def export_2(doc):
    backend = make_backend(doc)
    # auto-detect page size and 2mm margins on all sides
    page = layout.Page(0, 0, layout.Units.mm, margins=layout.Margins.all(2))
    # scale content by 10, do not fit content to page
    svg_string = backend.get_string(
The page has a size of 104x104mm, a content size of 100x100mm and 2mm margins on all sides.

../_images/image_export_04.png
Limit Page Size?
The page arguments max_width and max_height can limit the page size in auto-detection mode, e.g. most plotter devices can only print upto a width of 900mm.

See also

Page class

Margins class

Settings class

SVG Export?
The steps to export a SVG by the SVGBackend are show in the first example, the configuration of the frontend and the page setup are shown in the previous sections.

Create the render context

Create the backend

Create and configure the frontend

Draw the content

Setup the page layout

Create the SVG output string

This is the same code as for the first example:

def export(doc):
    msp = doc.modelspace()
    # 1. create the render context
    context = RenderContext(doc)
    # 2. create the backend
    backend = svg.SVGBackend()
    # 3. create the frontend
    frontend = Frontend(context, backend)
    # 4. draw the modelspace
    frontend.draw_layout(msp)
    # 5. create an A4 page layout, not required for all backends
    page = layout.Page(210, 297, layout.Units.mm, margins=layout.Margins.all(20))
    # 6. get the SVG rendering as string - this step is backend dependent
    svg_string = backend.get_string(page)
    with open("output.svg", "wt", encoding="utf8") as fp:
        fp.write(svg_string)
The SVG backend flips the coordinates along the y-axis and transforms the content into a compact integer coordinate space and produces therefore a small file size but therefore the output coordinates are different to the DXF coordinates.

PDF Export?
The PDF export requires the the PyMuPdf package to be installed.

The steps to export a PDF are very similar to SVG, except for the PyMuPdfBackend class and the backend returns bytes and not a string:

Create the render context

Create the backend

Create and configure the frontend

Draw the content

Setup the page layout

Create the SVG output string

Import the pymupdf backend module:

from ezdxf.addons.drawing import Frontend, RenderContext, pymupdf, layout, config
The export function:

def export_dark_bg(doc):
    msp = doc.modelspace()
    # 1. create the render context
    context = RenderContext(doc)
    # 2. create the backend
    backend = pymupdf.PyMuPdfBackend()
    # 3. create the frontend
    frontend = Frontend(context, backend)
    # 4. draw the modelspace
    frontend.draw_layout(msp)
    # 5. create an A4 page layout
    page = layout.Page(210, 297, layout.Units.mm, margins=layout.Margins.all(20))
    # 6. get the PDF rendering as bytes
    pdf_bytes = backend.get_pdf_bytes(page)
    with open("pdf_dark_bg.pdf", "wb") as fp:
        fp.write(pdf_bytes)
../_images/image_export_pdf_01.png
The PDF has is dark background for the modelspace by default and color index 7 is white. Create a frontend configuration and override the BackgroundPolicy to get a white background:

    # 3. create and configure the frontend
    cfg = config.Configuration(background_policy=config.BackgroundPolicy.WHITE)
    frontend = Frontend(context, backend, config=cfg)
Now the exported PDF has a white background and color index 7 is black:

../_images/image_export_pdf_02.png
PNG Export?
The PNG export is done by the PyMuPdfBackend class and differs only in the method to get the PNG data bytes:

    # 6. get the PNG rendering as bytes
    png_bytes = backend.get_pixmap_bytes(page, fmt="png", dpi=96)
    with open("png_white_bg.png", "wb") as fp:
        fp.write(png_bytes)
The pymupdf backend supports multiple image formats:

png

Portable Network Graphics

ppm

Portable Pixmap (no alpha channel)

pbm

Portable Bitmap (no alpha channel)

PLT/HPGL2 Export?
The PlotterBackend creates HPGL/2 plot files for output on raster plotters. The PlotterBackend is designed to print on white paper, so the background color is always white and color index 7 is black by default.

Warning

The plot files are only tested by the plot file viewer ViewCompanion Standard but not on real hardware - please use with care and give feedback.

The PLT/HPGL2 export is very similar to the SVG export:

from ezdxf.addons.drawing import Frontend, RenderContext, hpgl2, layout


def export(doc):
    msp = doc.modelspace()
    # 1. create the render context
    context = RenderContext(doc)
    # 2. create the backend
    backend = hpgl2.PlotterBackend()
    # 3. create the frontend
    frontend = Frontend(context, backend)
    # 4. draw the modelspace
    frontend.draw_layout(msp)
    # 5. create an A4 page layout
    page = layout.Page(210, 297, layout.Units.mm, margins=layout.Margins.all(20))
    # 6. get the HPGL2 rendering as bytes
    plt_bytes = backend.get_bytes(page)
    with open("output_01.plt", "wb") as fp:
        fp.write(plt_bytes)
../_images/image_export_plt_01.png
The HPGL/2 viewer does not show the margins around the content, but most construction drawings draw the page borders around the content.

The PlotterBackend has some quality preset methods to get the HPGL/2 data:

compatible()

low_quality()

normal_quality() (default)

high_quality()

The difference are mostly the floating point precision and the usage of B zier curves, but the B zier curves are approximated by plotter drivers (even by HP drivers), so there is no real quality improvement, but curves need less space than approximated polylines so the file size is smaller.

Very old plotter may not support B zier curves and floating point coordinates, for these plotters the compatible() method exports only polylines and integer coordinates.

Usage:

# 6. get the HPGL2 rendering as bytes
plt_bytes = backend.high_quality(page)
DXF Export?
The DXFBackend exports the content as DXF primitives: POINT, LINE, LWPOLYLINE, SPLINE and HATCH. All blocks are exploded, text is rendered as filled polygons represented by the HATCH entity and arcs are represented by SPLINE entities (internal B zier curve representation).

This backend was added to convert HPGL/2 files to DXF files, because the hpgl2 add-on reuses the backends of the drawing add-on for export. Maybe it is useful for other tasks too.

This backend works different than the previous. There is no page setup and everything is rendered into a given layout of a DXF document:

from ezdxf.addons.drawing import Frontend, RenderContext, dxf


def export(doc):
    export_doc = ezdxf.new()
    msp = doc.modelspace()
    # 1. create the render context
    context = RenderContext(doc)
    # 2. create the backend
    backend = dxf.DXFBackend(export_doc.modelspace())
    # 3. create the frontend
    frontend = Frontend(context, backend)
    # 4. draw the modelspace
    frontend.draw_layout(msp)
    # 5. save or return DXF document
    export_doc.saveas("output_01.dxf")
Recorder Backend?
The Recorder backend is an intermediate layer to record the drawing commands of the Frontend class. The Player object can replay this records on any other backend class but also provides some additional features like bounding box detection, content transformation and cropping.

The SVG/PDF/PLT backends use this intermediate layer internally to transform and place the content.

Previous Next
© Copyright 2011-2025, Manfred Moitzi.

Built with Sphinx using a theme provided by Read the Docs.
===== https://ezdxf.readthedocs.io/en/stable/tutorials/find_chains_and_loops.html ===== [Fetch failed]